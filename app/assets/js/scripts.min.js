/*!
 * rpgs
 * RPG System
 * https://github.com/stanosky/rpgs
 * @author Krzysztof Stano
 * @version 1.0.0
 * Copyright 2017. MIT licensed.
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict'

module.exports = {
  compileCode,
  compileExpression,
  expose,
  hide
}

let globalObj
if (typeof window !== 'undefined') globalObj = window // eslint-disable-line
else if (typeof global !== 'undefined') globalObj = global // eslint-disable-line
else if (typeof self !== 'undefined') globalObj = self // eslint-disable-line
globalObj.$nxCompileToSandbox = toSandbox
globalObj.$nxCompileCreateBackup = createBackup

const proxies = new WeakMap()
const expressionCache = new Map()
const codeCache = new Map()
const globals = new Set()
const handlers = {has}

function compileExpression (src) {
  if (typeof src !== 'string') {
    throw new TypeError('first argument must be a string')
  }
  let expression = expressionCache.get(src)
  if (!expression) {
    expression = new Function('context', // eslint-disable-line
      `const sandbox = $nxCompileToSandbox(context)
      try { with (sandbox) { return ${src} } } catch (err) {
        if (!(err instanceof TypeError)) throw err
      }`)
    expressionCache.set(src, expression)
  }
  return expression
}

function compileCode (src) {
  if (typeof src !== 'string') {
    throw new TypeError('first argument must be a string')
  }
  let code = codeCache.get(src)
  if (!code) {
    code = new Function('context', 'tempVars', // eslint-disable-line
    `const backup = $nxCompileCreateBackup(context, tempVars)
    Object.assign(context, tempVars)
    const sandbox = $nxCompileToSandbox(context)
    try {
      with (sandbox) { ${src} }
    } finally {
      Object.assign(context, backup)
    }`)
    codeCache.set(src, code)
  }
  return code
}

function expose (...globalNames) {
  for (let globalName of globalNames) {
    globals.add(globalName)
  }
}

function hide (...globalNames) {
  for (let globalName of globalNames) {
    globals.delete(globalName)
  }
}

function toSandbox (obj) {
  if (typeof obj !== 'object') {
    throw new TypeError('first argument must be an object')
  }
  let sandbox = proxies.get(obj)
  if (!sandbox) {
    sandbox = new Proxy(obj, handlers)
    proxies.set(obj, sandbox)
  }
  return sandbox
}

function createBackup (context, tempVars) {
  if (typeof tempVars === 'object') {
    const backup = {}
    for (let key of Object.keys(tempVars)) {
      backup[key] = context[key]
    }
    return backup
  }
}

function has (target, key) {
  return globals.has(key) ? Reflect.has(target, key) : true
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
module.exports={"actors":[{"class":"ActorNode","uuid":"act1","input":{"dialog":["2d91e675-9c2d-48d9-87d0-b0260b403059"]},"name":"Adam"}],"logic":[{"class":"ScriptNode","uuid":"cond1","output":{"visibility":["c94b4f1d-2114-43ba-b9b1-f45fb026e07f"]},"label":"","script":"return 2>1 && rpgs.getVar('b1') === false;"}],"dialogs":[{"class":"DialogNode","uuid":"dlg1","input":{},"output":{"dialog":["2d91e675-9c2d-48d9-87d0-b0260b403059"]},"children":["tlk0","tlk1","tlk2","tlk3"],"startTalk":"tlk0"}],"links":[{"class":"LinkNode","uuid":"2d91e675-9c2d-48d9-87d0-b0260b403059","input":"act1","output":"dlg1","type":"dialog"},{"class":"LinkNode","uuid":"c94b4f1d-2114-43ba-b9b1-f45fb026e07f","input":"tlk0ans1","output":"cond1","type":"visibility"},{"class":"LinkNode","uuid":"3184673f-06e6-41dc-ac72-89b2e58e3803","input":"tlk1","output":"tlk0ans1","type":"goto"},{"class":"LinkNode","uuid":"0fb1d66a-b3e7-49af-b802-12529115965b","input":"tlk2","output":"tlk0ans2","type":"goto"},{"class":"LinkNode","uuid":"92f9fb79-f21a-4bf8-bfa4-7b1bbfc64b7c","input":"tlk3","output":"tlk0ans3","type":"goto"}],"talks":[{"class":"TalkNode","uuid":"tlk0","input":{},"children":["tlk0ans1","tlk0ans2","tlk0ans3"],"text":"This is talk 0."},{"class":"TalkNode","uuid":"tlk1","input":{"goto":["3184673f-06e6-41dc-ac72-89b2e58e3803"]},"children":["tlk1ans1"],"text":"This is talk 1."},{"class":"TalkNode","uuid":"tlk2","input":{"goto":["0fb1d66a-b3e7-49af-b802-12529115965b"]},"children":["tlk2ans1"],"text":"This is talk 2."},{"class":"TalkNode","uuid":"tlk3","input":{"goto":["92f9fb79-f21a-4bf8-bfa4-7b1bbfc64b7c"]},"children":["tlk3ans1"],"text":"This is talk 3."}],"answers":[{"class":"AnswerNode","uuid":"tlk0ans1","input":{"visibility":["c94b4f1d-2114-43ba-b9b1-f45fb026e07f"]},"output":{"goto":["3184673f-06e6-41dc-ac72-89b2e58e3803"]},"text":"Answer1"},{"class":"AnswerNode","uuid":"tlk0ans2","input":{},"output":{"goto":["0fb1d66a-b3e7-49af-b802-12529115965b"]},"text":"Answer2"},{"class":"AnswerNode","uuid":"tlk0ans3","input":{},"output":{"goto":["92f9fb79-f21a-4bf8-bfa4-7b1bbfc64b7c"]},"text":"Answer3"},{"class":"AnswerNode","uuid":"tlk1ans1","input":{},"output":{},"text":"Answer1"},{"class":"AnswerNode","uuid":"tlk2ans1","input":{},"output":{},"text":"Answer1"},{"class":"AnswerNode","uuid":"tlk3ans1","input":{},"output":{},"text":"Answer1"}],"variables":[{"class":"VariableNode","uuid":"b1","input":{},"output":{},"type":"boolean","value":false},{"class":"VariableNode","uuid":"s1","input":{},"output":{},"type":"string","value":"This is message from compiled code!"},{"class":"VariableNode","uuid":"n1","input":{},"output":{},"type":"number","value":56}]}

},{}],3:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
//import InventoryNode  from './actors/InventoryNode';


var _Utils = require('./core/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _ErrorHandler = require('./core/ErrorHandler');

var _ErrorHandler2 = _interopRequireDefault(_ErrorHandler);

var _ErrorCode = require('./core/ErrorCode');

var _ErrorCode2 = _interopRequireDefault(_ErrorCode);

var _BaseNode = require('./core/BaseNode');

var _BaseNode2 = _interopRequireDefault(_BaseNode);

var _ActorNode = require('./actors/ActorNode');

var _ActorNode2 = _interopRequireDefault(_ActorNode);

var _ScriptNode = require('./logic/ScriptNode');

var _ScriptNode2 = _interopRequireDefault(_ScriptNode);

var _AnswerNode = require('./dialogs/AnswerNode');

var _AnswerNode2 = _interopRequireDefault(_AnswerNode);

var _DialogNode = require('./dialogs/DialogNode');

var _DialogNode2 = _interopRequireDefault(_DialogNode);

var _TalkNode = require('./dialogs/TalkNode');

var _TalkNode2 = _interopRequireDefault(_TalkNode);

var _QuestNode = require('./quests/QuestNode');

var _QuestNode2 = _interopRequireDefault(_QuestNode);

var _TaskNode = require('./quests/TaskNode');

var _TaskNode2 = _interopRequireDefault(_TaskNode);

var _VariableNode = require('./variables/VariableNode');

var _VariableNode2 = _interopRequireDefault(_VariableNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KEY_ACTORS = 'actors';
var KEY_ANSWERS = 'answers';
var KEY_LOGIC = 'logic';
var KEY_DIALOGS = 'dialogs';
var KEY_LINKS = 'links';
var KEY_SCRIPTS = 'scripts';
var KEY_TALKS = 'talks';
var KEY_TASKS = 'tasks';
var KEY_QUESTS = 'quests';
var KEY_VARIABLES = 'variables';

var RPGSystem = function RPGSystem(data, editor) {
  var _objectPool = {},
      _editor = editor || null,
      _errorHandler = new _ErrorHandler2.default(_editor),
      _context = null,
      _lastChild = null,
      _parentHistory = [],
      _tempWires = [];

  function _nodeFactory(data, rpgs) {
    var className = data.class;
    switch (className) {
      case 'ActorNode':
        return new _ActorNode2.default(data, rpgs);
      case 'ScriptNode':
        return new _ScriptNode2.default(data, rpgs);
      case 'AnswerNode':
        return new _AnswerNode2.default(data, rpgs);
      case 'DialogNode':
        return new _DialogNode2.default(data, rpgs);
      case 'TalkNode':
        return new _TalkNode2.default(data, rpgs);
      case 'QuestNode':
        return new _QuestNode2.default(data, rpgs);
      case 'TaskNode':
        return new _TaskNode2.default(data, rpgs);
      //case 'LinkNode':      return new LinkNode(data,rpgs);
      case 'VariableNode':
        return new _VariableNode2.default(data, rpgs);
      default:
        _errorHandler.showMsg(_ErrorCode2.default.CLASS_NOT_DEFINED, { class: className });
        return null;
    }
  }

  function _findNodeInArray(array, id) {
    for (var i = 0; i < array.length; i++) {
      if (array[i].getId() === id) return array[i];
    }
    return null;
  }

  var _findNode = function _findNode(objId) {
    for (var key in _objectPool) {
      if (_objectPool.hasOwnProperty(key)) {
        var obj = _findNodeInArray(_objectPool[key], objId);
        if (obj !== null) return obj;
      }
    }
    //Is error message neccessary here? To consider.
    //_errorHandler.showMsg(ErrorCode.OBJECT_NOT_FOUND,{id:objId});
    return null;
  },
      _addNode = function _addNode(key, obj) {
    if (!_objectPool[key]) _objectPool[key] = [];
    _objectPool[key].push(obj);
  },
      _removeNode = function _removeNode(id) {
    for (var key in _objectPool) {
      if (_objectPool.hasOwnProperty(key)) {
        if (this._removeNodeByKey(key, id)) return true;
      }
    }
    return false;
  },
      _removeNodeByKey = function _removeNodeByKey(key, id) {
    var index = _Utils2.default.getIndexById(_objectPool[key], id);
    var isNodeFound = index > -1;
    if (isNodeFound) {
      var node = _objectPool[key].splice(index, 1)[0];
      node.dispose();
    }
    return isNodeFound;
  },
      _setConnection = function _setConnection(type, nodeId1, nodeId2) {
    if (nodeId1 === nodeId2) {
      _errorHandler.showMsg(_ErrorCode2.default.CONNECTION_TO_ITSELF, { node: nodeId1 });
    }
    var node1 = _findNode(nodeId1);
    var node2 = _findNode(nodeId2);
    if (node2 === null) {
      console.log('rpgs::tempWire', type, nodeId1, nodeId2);
      _tempWires.push({ type: type, targetNode: nodeId1, referenceNode: nodeId2 });
      return;
    }
    if (node1.canSetWireType(type)) {
      console.log('rpgs::createWire', type, nodeId1, nodeId2);
      node1.setWire(type, node2.getId());
    } else {
      _errorHandler.showMsg(_ErrorCode2.default.IMPROPER_CONNECTION, {
        type: type,
        node1: nodeId1,
        node2: nodeId2
      });
    }
  };

  ////////////////////////////////////////////////////////////////
  //METHOD CHAINING
  ////////////////////////////////////////////////////////////////

  /**
   * Method used to check passed parameters and later merge them into
   * single object.
   * @param  {string} id      Mandatory id of node.
   * @param  {object} params  Optional parameters.
   * @return {object} Parameters merged into object.
   */
  function _checkAndMergeParams() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _errorHandler.showMsg(_ErrorCode2.default.MANDATORY_PARAM, { param: 'id' });
    var params = arguments[1];

    if (typeof id !== 'string') {
      _errorHandler.showMsg(_ErrorCode2.default.INCORRECT_TYPE, { type: 'string' });
    }
    if (params !== undefined && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) !== 'object') {
      _errorHandler.showMsg(_ErrorCode2.default.INCORRECT_TYPE, { type: 'object' });
    } else if (params === undefined) {
      params = {};
    }
    params.uuid = id;
    return params;
  }

  /**
   * This method helps in the creation of nodes. Its focus on proper
   * placement of nodes in tree.
   * @param  {string} id      Mandatory id of newly created node.
   * @param  {object} params  Parameters of created node.
   * @param  {boolean} asChild Determines if node should be added as child
   * of another node or as an independent node.
   * @param  {string} className   Name of class that will be used to create node.
   * @param  {string} storage Name of node group inside which node will be added.
   */
  function _chainNodeCreator(id, params, asChild, className, storage) {
    //First, we check that id and params are valid.
    params = _checkAndMergeParams(id, params);
    //Class name for later usage.
    params.class = className;

    //Test if node should be added as child or parent.
    if (asChild) {
      //If last added child was not null then we must check additional conditions.
      if (_lastChild !== null) {
        //If constructor name of previous child node, is equal to name of class,
        //whose we try to create, it means node should be added to current parent.
        if (_lastChild.constructor.name === className) {
          createChildNode(params);
        }
        //If names of constructors not match, then we must check if new node
        //can be added as child to our previous child.
        else if (_lastChild.canAddChild(className)) {
            _parentHistory.unshift(_lastChild);
            createChildNode(params);
          }
          //Finally if previous conditions are false we try go back to previous
          //parent node.
          else {
              _lastChild = _parentHistory.shift() || null;
              _chainNodeCreator(id, params, asChild, className, storage);
            }
      }
      //If last child is null, then we check if node can be added to current
      //parent node.
      else if (_parentHistory.length > 0 && _parentHistory[0].canAddChild(className)) {
          createChildNode(params);
        }
        //If last child and last parent is equal to null, then new child node
        //cant be added, so we throw error.
        else {
            _errorHandler.showMsg(_ErrorCode2.default.INCOMPATIBLE_CHILD, {
              child: className,
              parent: _parentHistory.length > 0 ? _parentHistory[0].constructor.name : 'null'
            });
          }
    } else {
      //If node is added as parent, then last child is set to null
      //and parent history is cleared.
      _lastChild = null;
      _parentHistory.length = 0;
      //After that, new node is created.
      var node = _nodeFactory(params, _self);
      _parentHistory = [node];
      _addNode(storage, node);
    }

    _getWaitingWiresForNode(id).map(function (wire) {
      //console.log('wire',wire,wire.type,wire.targetNode,wire.referenceNode);
      _setConnection(wire.type, wire.targetNode, wire.referenceNode);
      return null;
    });

    function createChildNode(nodeParams) {
      //We create a new node, and then set as the last child.
      _lastChild = _nodeFactory(nodeParams, _self);
      //Then we add our freshly created node to its parent.
      _parentHistory[0].addChild(_lastChild.getId());
      //Finally new node is added to main storage object.
      _addNode(storage, _lastChild);
    }
  }

  function _getWaitingWiresForNode(nodeId) {
    var wires = [];
    for (var i = _tempWires.length - 1; i >= 0; i--) {
      //console.log('_getWaitingWiresForNode',_tempWires[i].referenceNode,nodeId);
      if (_tempWires[i].referenceNode === nodeId) {
        wires.push(_tempWires.splice(i, 1)[0]);
      }
    }
    return wires;
  }

  /**
   * Helper method that is used to remove nodes from object pool
   * and reset context of "method chaining" algorithm.
   * @param  {string} id  Id of node to be removed.
   * @param  {string} key Name of node group which contains node to remove.
   */
  function _chainNodeRemover(id, key) {
    _lastChild = null;
    _parentHistory.length = 0;
    this._removeNodeByKey(key, id);
  }

  var _addActor = function _addActor(id, params) {
    _chainNodeCreator(id, params, false, 'ActorNode', KEY_ACTORS);
    return this;
  },
      _removeActor = function _removeActor(actorId) {
    _chainNodeRemover(actorId, KEY_ACTORS);
    return this;
  },
      _addQuest = function _addQuest(id, params) {
    _chainNodeCreator(id, params, false, 'QuestNode', KEY_QUESTS);
    return this;
  },
      _removeQuest = function _removeQuest(questId) {
    _chainNodeRemover(questId, KEY_QUESTS);
    return this;
  },
      _addDialog = function _addDialog(id, params) {
    _chainNodeCreator(id, params, false, 'DialogNode', KEY_DIALOGS);
    return this;
  },
      _removeDialog = function _removeDialog(dialogId) {
    _chainNodeRemover(dialogId, KEY_DIALOGS);
    return this;
  },
      _addCondition = function _addCondition(id, params) {
    _chainNodeCreator(id, params, false, 'ScriptNode', KEY_LOGIC);
    return this;
  },
      _removeCondition = function _removeCondition(conditionId) {
    _chainNodeRemover(conditionId, KEY_LOGIC);
    return this;
  },
      _addVariable = function _addVariable(id, params) {
    _chainNodeCreator(id, params, false, 'VariableNode', KEY_VARIABLES);
    return this;
  },
      _removeVariable = function _removeVariable(variableId) {
    _chainNodeRemover(variableId, KEY_VARIABLES);
    return this;
  },
      _addTalk = function _addTalk(id, params) {
    _chainNodeCreator(id, params, true, 'TalkNode', KEY_TALKS);
    return this;
  },
      _removeTalk = function _removeTalk(id) {
    _chainNodeRemover(id, KEY_TALKS);
    return this;
  },
      _addAnswer = function _addAnswer(id, params) {
    _chainNodeCreator(id, params, true, 'AnswerNode', KEY_ANSWERS);
    return this;
  },
      _removeAnswer = function _removeAnswer(id) {
    _chainNodeRemover(id, KEY_ANSWERS);
    return this;
  },
      _setWire = function _setWire(type, referenceNodeId) {
    var targetNode = _lastChild;
    if (targetNode === null && _parentHistory.length > 0) {
      targetNode = _parentHistory[0];
    } else {
      /*_errorHandler.showMsg(ErrorCode.INCOMPATIBLE_CHILD,{
        child:className,
        parent: _parentHistory.length > 0
              ? _parentHistory[0].constructor.name
              : 'null'
      });*/
    }
    _setConnection(type, targetNode.getId(), referenceNodeId);
    return this;
  },


  ////////////////////////////////////////////////////////////////
  //GETTERS
  ////////////////////////////////////////////////////////////////
  _getActor = function _getActor(actorId) {
    return this._findNode(actorId);
  },
      _getActors = function _getActors() {
    return _objectPool[KEY_ACTORS];
  },
      _getCondition = function _getCondition(conditionId) {
    return _findNode(conditionId);
  },
      _getConditions = function _getConditions() {
    return _objectPool[KEY_LOGIC];
  },
      _getDialog = function _getDialog(dialogId) {
    return _findNode(dialogId);
  },
      _getDialogs = function _getDialogs() {
    return _objectPool[KEY_DIALOGS];
  },
      _getQuest = function _getQuest(questId) {
    return _findNode(questId);
  },
      _getQuests = function _getQuests() {
    return _objectPool[KEY_QUESTS];
  },
      _getVariable = function _getVariable(variableId) {
    return _findNode(variableId);
  },
      _getVariables = function _getVariables() {
    return _objectPool[KEY_VARIABLES];
  },


  ////////////////////////////////////////////////////////////////
  //MISCALINEUS
  ////////////////////////////////////////////////////////////////

  _setVar = function _setVar(variableId, value) {
    var _var = _getVariable(variableId);
    if (_var !== null) _var.setValue(value);
  },
      _getVar = function _getVar(variableId) {
    var _var = _getVariable(variableId);
    return _var !== null ? _var.getValue() : undefined;
  },
      _serializeData = function _serializeData() {
    var data = {};
    for (var key in _objectPool) {
      if (_objectPool.hasOwnProperty(key)) {
        data[key] = _objectPool[key].map(function (obj) {
          return obj.getData ? obj.getData() : obj;
        });
      }
    }
    return JSON.stringify(data);
  };

  var _self = {
    ////////////////////////////////////////////
    //General node methods
    ////////////////////////////////////////////
    findNode: _findNode,
    //getNode:          _getNode,
    addNode: _addNode,
    removeNode: _removeNode,

    ////////////////////////////////////////////
    //Link creation methods
    ////////////////////////////////////////////
    setWire: _setWire,

    ////////////////////////////////////////////
    //Chainable methods
    ////////////////////////////////////////////
    addActor: _addActor,
    removeActor: _removeActor,
    addQuest: _addQuest,
    removeQuest: _removeQuest,
    addDialog: _addDialog,
    removeDialog: _removeDialog,
    addCondition: _addCondition,
    removeCondition: _removeCondition,
    addVariable: _addVariable,
    removeVariable: _removeVariable,
    addTalk: _addTalk,
    removeTalk: _removeTalk,
    addAnswer: _addAnswer,
    removeAnswer: _removeAnswer,
    //inp:             _inp,
    //out:             _out,

    ////////////////////////////////////////////
    //Getter methods
    ////////////////////////////////////////////
    getActor: _getActor,
    getActors: _getActors,
    getCondition: _getCondition,
    getConditions: _getConditions,
    getDialog: _getDialog,
    getDialogs: _getDialogs,
    getQuest: _getQuest,
    getQuests: _getQuests,
    getVariable: _getVariable,
    getVariables: _getVariables,

    ////////////////////////////////////////////
    //Miscalineus methods
    ////////////////////////////////////////////
    setVar: _setVar,
    getVar: _getVar,
    serializeData: _serializeData
  };

  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      _objectPool[key] = data[key].map(function (d) {
        return _nodeFactory(d, _self);
      });
    }
  }

  return _self;
};
module.exports = RPGSystem;

},{"./actors/ActorNode":4,"./core/BaseNode":5,"./core/ErrorCode":7,"./core/ErrorHandler":8,"./core/Utils":10,"./dialogs/AnswerNode":11,"./dialogs/DialogNode":12,"./dialogs/TalkNode":14,"./logic/ScriptNode":15,"./quests/QuestNode":16,"./quests/TaskNode":18,"./variables/VariableNode":19}],4:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseNode2 = require('../core/BaseNode');

var _BaseNode3 = _interopRequireDefault(_BaseNode2);

var _Prop = require('../core/Prop');

var _Prop2 = _interopRequireDefault(_Prop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ActorNode = function () {
  //Weak maps are new feature to JavaScript. We can store private
  //object properties in key/value pairs using our instance as the key,
  //and our class can capture those key/value maps in a closure.
  var _name = new WeakMap();
  var _dialog = new WeakMap();
  //let _inventory = new WeakMap();


  return function (_BaseNode) {
    _inherits(ActorNode, _BaseNode);

    function ActorNode(data) {
      _classCallCheck(this, ActorNode);

      var _this = _possibleConstructorReturn(this, (ActorNode.__proto__ || Object.getPrototypeOf(ActorNode)).call(this, data));

      _name.set(_this, data ? data.name : '');
      _dialog.set(_this, data ? data.dialog : '');
      //_inventory.set(this,data.inventory ? );
      return _this;
    }

    _createClass(ActorNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(ActorNode.prototype.__proto__ || Object.getPrototypeOf(ActorNode.prototype), 'getData', this).call(this);
        data.name = this.getName();
        data.dialog = this.getDialog();
        return data;
      }
    }, {
      key: 'setName',
      value: function setName(value) {
        _name.set(this, value);
      }
    }, {
      key: 'getName',
      value: function getName() {
        return _name.get(this);
      }
    }, {
      key: 'getDialog',
      value: function getDialog() {
        return _dialog.get(this);
      }

      /*getInventory() {
        return _inventory.get(this);
      }*/

    }, {
      key: 'canSetWireType',
      value: function canSetWireType(type) {
        switch (type) {
          case _Prop2.default.DIALOG:
            return this.getWires(_Prop2.default.DIALOG).length === 0;
          default:
            return false;
        }
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _name.delete(this);
        _dialog.delete(this);
        //_inventory.delete(this);
        _get(ActorNode.prototype.__proto__ || Object.getPrototypeOf(ActorNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return ActorNode;
  }(_BaseNode3.default);
}();

module.exports = ActorNode;

},{"../core/BaseNode":5,"../core/Prop":9}],5:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Utils = require('./Utils');

var _Prop = require('./Prop');

var _Prop2 = _interopRequireDefault(_Prop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BaseNode = function () {
  //Weak maps are new feature to JavaScript. We can store private
  //object properties in key/value pairs using our instance as the key,
  //and our class can capture those key/value maps in a closure.
  var _rpgs = new WeakMap();
  var _uuid = new WeakMap();
  var _wires = new WeakMap();

  return function () {
    function BaseNode(data, rpgs) {
      _classCallCheck(this, BaseNode);

      _rpgs.set(this, rpgs);
      //If uuid not present, then by default we assign Universally Unique ID.
      _uuid.set(this, data.uuid ? data.uuid : _Utils.UUID.generate());
      _wires.set(this, data.wires ? data.wires : {});
    }

    _createClass(BaseNode, [{
      key: 'getRPGS',
      value: function getRPGS() {
        return _rpgs.get(this);
      }
    }, {
      key: 'setId',
      value: function setId(value) {
        _uuid.set(this, value);
      }
    }, {
      key: 'getId',
      value: function getId() {
        return _uuid.get(this);
      }
    }, {
      key: '_checkCondition',
      value: function _checkCondition(prop) {
        var nodeId = this.getWires(prop)[0];
        var scriptNode = this.getRPGS().findNode(nodeId);
        return scriptNode != null && scriptNode.execute ? scriptNode.execute() : true;
      }

      /**
       * Returns boolean that reflects visiblility state of node.
       * @return {Boolean} Visibility state
       */

    }, {
      key: 'isVisible',
      value: function isVisible() {
        return this._checkCondition(_Prop2.default.VISIBILITY);
      }

      /**
       * Returns boolean that reflects activity state of node.
       * @return {Boolean} Active state
       */

    }, {
      key: 'isActive',
      value: function isActive() {
        return this._checkCondition(_Prop2.default.ACTIVITY);
      }
    }, {
      key: 'getData',
      value: function getData() {
        return {
          class: this.constructor.name,
          uuid: this.getId(),
          wires: _wires.get(this)
        };
      }
    }, {
      key: 'canAddChild',
      value: function canAddChild(type) {
        return false;
      }
    }, {
      key: 'addChild',
      value: function addChild(childId) {}
    }, {
      key: 'removeChild',
      value: function removeChild(index) {}
    }, {
      key: 'getChild',
      value: function getChild(index) {
        return null;
      }
    }, {
      key: 'getChildren',
      value: function getChildren() {
        return [];
      }
    }, {
      key: '_removeChildren',
      value: function _removeChildren() {}
    }, {
      key: 'canSetWireType',
      value: function canSetWireType(type) {
        return false;
      }
    }, {
      key: '_setWire',
      value: function _setWire(obj, type, nodeId) {
        if (!obj.hasOwnProperty(type)) {
          obj[type] = [];
        }
        obj[type].push(nodeId);
        return obj;
      }
    }, {
      key: 'setWire',
      value: function setWire(type, nodeId) {
        _wires.set(this, this._setWire(_wires.get(this), type, nodeId));
      }
    }, {
      key: '_getWires',
      value: function _getWires(obj, type) {
        //console.log('_getWires',obj);
        if (type) return !obj.hasOwnProperty(type) ? [] : obj[type];else return obj;
      }
    }, {
      key: 'getWires',
      value: function getWires(type) {
        return this._getWires(_wires.get(this), type);
      }
    }, {
      key: '_removeWire',
      value: function _removeWire(obj, type, nodeId) {
        if (obj.hasOwnProperty(type)) {
          obj[type] = Utils.removeObjectFromArray(obj[type], nodeId);
        }
        return obj;
      }
    }, {
      key: 'removeWire',
      value: function removeWire(type, nodeId) {
        _wires.set(this, this._removeWire(_wires.get(this), type, nodeId));
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _rpgs.delete(this);
        _uuid.delete(this);
        _wires.delete(this);
        _removeChildren();
      }
    }]);

    return BaseNode;
  }();
}();
module.exports = BaseNode;

},{"./Prop":9,"./Utils":10}],6:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseNode2 = require('../core/BaseNode');

var _BaseNode3 = _interopRequireDefault(_BaseNode2);

var _Utils = require('../core/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CompoundNode = function () {
  var _children = new WeakMap();

  return function (_BaseNode) {
    _inherits(CompoundNode, _BaseNode);

    function CompoundNode(data, rpgs) {
      _classCallCheck(this, CompoundNode);

      var _this = _possibleConstructorReturn(this, (CompoundNode.__proto__ || Object.getPrototypeOf(CompoundNode)).call(this, data, rpgs));

      _children.set(_this, data.children ? data.children : []);
      return _this;
    }

    _createClass(CompoundNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(CompoundNode.prototype.__proto__ || Object.getPrototypeOf(CompoundNode.prototype), 'getData', this).call(this);
        data.children = this.getChildren();
        return data;
      }
    }, {
      key: 'addChild',
      value: function addChild(childId) {
        var children = _children.get(this);
        _children.set(this, _Utils2.default.addObjectToArray(children, childId));
      }
    }, {
      key: 'removeChild',
      value: function removeChild(index) {
        var children = _children.get(this);
        _children.set(this, children.splice(index, 1));
      }
    }, {
      key: 'getChild',
      value: function getChild(index) {
        var children = _children.get(this);
        return children.length > index ? children[index] : null;
      }
    }, {
      key: 'getChildren',
      value: function getChildren() {
        return _children.get(this);
      }
    }, {
      key: '_removeChildren',
      value: function _removeChildren() /*key*/{
        //Add valid implementation...
        //this.removeChildrenFrom(_children.get(this),key);
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _children.delete(this);
        _get(CompoundNode.prototype.__proto__ || Object.getPrototypeOf(CompoundNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return CompoundNode;
  }(_BaseNode3.default);
}();
module.exports = CompoundNode;

},{"../core/BaseNode":5,"../core/Utils":10}],7:[function(require,module,exports){
"use strict";

var NODE_NOT_EXISTS = 0;
var CLASS_NOT_DEFINED = 1;
var CONNECTION_TO_ITSELF = 2;
var IMPROPER_CONNECTION = 3;
var OBJECT_NOT_FOUND = 4;
var MANDATORY_PARAM = 5;
var INCORRECT_TYPE = 6;
var INCORRECT_PARENT_NODE = 7;
var INCORRECT_LINK_TARGET = 8;
var INCOMPATIBLE_CHILD = 9;

exports.NODE_NOT_EXISTS = NODE_NOT_EXISTS;
exports.CLASS_NOT_DEFINED = CLASS_NOT_DEFINED;
exports.CONNECTION_TO_ITSELF = CONNECTION_TO_ITSELF;
exports.IMPROPER_CONNECTION = IMPROPER_CONNECTION;
exports.OBJECT_NOT_FOUND = OBJECT_NOT_FOUND;
exports.MANDATORY_PARAM = MANDATORY_PARAM;
exports.INCORRECT_TYPE = INCORRECT_TYPE;
exports.INCORRECT_PARENT_NODE = INCORRECT_PARENT_NODE;
exports.INCORRECT_LINK_TARGET = INCORRECT_LINK_TARGET;
exports.INCOMPATIBLE_CHILD = INCOMPATIBLE_CHILD;

},{}],8:[function(require,module,exports){
"use strict";

var _ErrorCode = require('./ErrorCode');

var _ErrorCode2 = _interopRequireDefault(_ErrorCode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ErrorHandler = function ErrorHandler(editor) {
  return {
    showMsg: function showMsg(errorCode, params) {
      var msg = '';
      switch (errorCode) {
        case _ErrorCode2.default.NODE_NOT_EXISTS:
          msg = 'Node of type ' + params.type + ' is not defined.';
          break;
        case _ErrorCode2.default.CLASS_NOT_DEFINED:
          msg = 'Class ' + params.class + ' is not defined.';
          break;
        case _ErrorCode2.default.CONNECTION_TO_ITSELF:
          msg = 'Cannot connect node "' + params.node + '" to itself.';
          break;
        case _ErrorCode2.default.IMPROPER_CONNECTION:
          msg = 'Cannot create connection of type "' + params.type + '" from node id "' + params.node1 + '" to node id "' + params.node2 + '".';
          break;
        case _ErrorCode2.default.OBJECT_NOT_FOUND:
          msg = 'Cannot find object with id "' + params.id + '"';
          break;
        case _ErrorCode2.default.MANDATORY_PARAM:
          msg = 'Parameter "' + params.param + '" was expected but instead got undefined.';
          break;
        case _ErrorCode2.default.INCORRECT_TYPE:
          msg = 'Wrong type of argument. Expected "' + params.type + '"';
          break;
        case _ErrorCode2.default.INCORRECT_PARENT_NODE:
          msg = 'Node of type "' + params.child + '" can be added only to "' + params.parent + '" node.';
          break;
        case _ErrorCode2.default.INCORRECT_LINK_TARGET:
          msg = 'Cannot create link connection to null node.';
          break;
        case _ErrorCode2.default.INCOMPATIBLE_CHILD:
          msg = 'Cannot add child of type "' + params.child + '" into parent of type "' + params.parent + '".';
          break;
        default:
          msg = 'Unknown error code passed: ' + errorCode;
      }
      if (editor) {
        editor.showMsg(msg);
      } else {
        throw new Error(msg);
        //add warning mode?
      }
    }
  };
};
module.exports = ErrorHandler;

},{"./ErrorCode":7}],9:[function(require,module,exports){
"use strict";

var REFERENCE = 'reference';
var VISIBILITY = 'visibility';
var ACTIVITY = 'activity';
var ACTION = 'action';
var GOTO = 'goto';
var DIALOG = 'dialog';

exports.REFERENCE = REFERENCE;
exports.VISIBILITY = VISIBILITY;
exports.ACTIVITY = ACTIVITY;
exports.ACTION = ACTION;
exports.GOTO = GOTO;
exports.DIALOG = DIALOG;

},{}],10:[function(require,module,exports){
"use strict";

/**
 * Fast UUID generator, RFC4122 version 4 compliant.
 * @author Jeff Ward (jcward.com).
 * @license MIT license
 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
 **/

var UUID = function () {
  var self = {};
  var lut = [];for (var i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
  }
  self.generate = function () {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  };
  return self;
}();

exports.UUID = UUID;

var indexOfObject = function indexOfObject(array, obj) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === obj) return i;
  }
  return -1;
};

exports.indexOfObject = indexOfObject;

var getIndexById = function getIndexById(array, id) {
  for (var i = 0; i < array.length; i++) {
    if (array[i].getId() === id) return i;
  }
  return -1;
};
exports.getIndexById = getIndexById;

exports.addObjectToArray = function (array, obj, expectedType) {
  if (expectedType !== undefined && expectedType !== null) {
    if (expectedType.isPrototypeOf(obj)) {
      throw new Error('Wrong type of object passed. Expected ' + expectedType.constructor.name + ' object.');
    }
  }
  if (indexOfObject(array, obj) === -1) {
    array.push(obj);
  }
  return array;
};

/*exports.removeObjectById = function(array,id) {
  let index = getIndexById(array,id);
  if(index !== -1) {
    let spliced = array.splice(index,1);
    if(spliced.dispose) spliced.dispose();
  }
  return array;
}*/

exports.removeObjectFromArray = function (array, obj) {
  var index = indexOfObject(array, obj);
  if (index !== -1) {
    var spliced = array.splice(index, 1);
    if (spliced.dispose) spliced.dispose();
  }
  return array;
};

},{}],11:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseNode2 = require('../core/BaseNode');

var _BaseNode3 = _interopRequireDefault(_BaseNode2);

var _Prop = require('../core/Prop');

var _Prop2 = _interopRequireDefault(_Prop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AnswerNode = function () {
  //Weak maps are new feature to JavaScript. We can store private
  //object properties in key/value pairs using our instance as the key,
  //and our class can capture those key/value maps in a closure.
  var _text = new WeakMap();

  return function (_BaseNode) {
    _inherits(AnswerNode, _BaseNode);

    function AnswerNode(data, rpgs) {
      _classCallCheck(this, AnswerNode);

      var _this = _possibleConstructorReturn(this, (AnswerNode.__proto__ || Object.getPrototypeOf(AnswerNode)).call(this, data, rpgs));

      _text.set(_this, data.text ? data.text : '');
      return _this;
    }

    _createClass(AnswerNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(AnswerNode.prototype.__proto__ || Object.getPrototypeOf(AnswerNode.prototype), 'getData', this).call(this);
        data.text = this.getText();
        return data;
      }
    }, {
      key: 'setText',
      value: function setText(value) {
        _text.set(this, value);
      }
    }, {
      key: 'getText',
      value: function getText() {
        return _text.get(this);
      }
    }, {
      key: 'getTalk',
      value: function getTalk() {
        console.log('AnswerNode::getTalk', this.getWires(_Prop2.default.GOTO));
        return this.getWires(_Prop2.default.GOTO)[0];
      }
    }, {
      key: 'canSetWireType',
      value: function canSetWireType(type) {
        switch (type) {
          case _Prop2.default.VISIBILITY:
            return this.getWires(_Prop2.default.VISIBILITY).length === 0;
          case _Prop2.default.ACTIVITY:
            return this.getWires(_Prop2.default.ACTIVITY).length === 0;
          case _Prop2.default.GOTO:
            return this.getWires(_Prop2.default.GOTO).length === 0;
          default:
            return false;
        }
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _text.delete(this);
        _get(AnswerNode.prototype.__proto__ || Object.getPrototypeOf(AnswerNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return AnswerNode;
  }(_BaseNode3.default);
}();
module.exports = AnswerNode;

},{"../core/BaseNode":5,"../core/Prop":9}],12:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CompoundNode2 = require('../core/CompoundNode');

var _CompoundNode3 = _interopRequireDefault(_CompoundNode2);

var _Prop = require('../core/Prop');

var _Prop2 = _interopRequireDefault(_Prop);

var _Utils = require('../core/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_TALKS = 'talks';

var DialogNode = function () {
  var _start = new WeakMap();

  return function (_CompoundNode) {
    _inherits(DialogNode, _CompoundNode);

    function DialogNode(data, rpgs) {
      _classCallCheck(this, DialogNode);

      var _this = _possibleConstructorReturn(this, (DialogNode.__proto__ || Object.getPrototypeOf(DialogNode)).call(this, data, rpgs));

      _start.set(_this, data.startTalk ? data.startTalk : '');
      return _this;
    }

    _createClass(DialogNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(DialogNode.prototype.__proto__ || Object.getPrototypeOf(DialogNode.prototype), 'getData', this).call(this);
        data.startTalk = this.getStartTalk();
        return data;
      }
    }, {
      key: 'canAddChild',
      value: function canAddChild(type) {
        return type === 'TalkNode';
      }
    }, {
      key: 'setStartTalk',
      value: function setStartTalk(talkId) {
        _start.set(this, talkId);
      }
    }, {
      key: 'getStartTalk',
      value: function getStartTalk() {
        return _start.get(this);
      }
    }, {
      key: 'canSetWireType',
      value: function canSetWireType(type) {
        switch (type) {
          case _Prop2.default.VISIBILITY:
            return this.getWires(_Prop2.default.VISIBILITY).length === 0;
          case _Prop2.default.ACTIVITY:
            return this.getWires(_Prop2.default.ACTIVITY).length === 0;
          default:
            return false;
        }
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _start.delete(this);
        _get(DialogNode.prototype.__proto__ || Object.getPrototypeOf(DialogNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return DialogNode;
  }(_CompoundNode3.default);
}();
module.exports = DialogNode;

},{"../core/CompoundNode":6,"../core/Prop":9,"../core/Utils":10}],13:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DialogWalker = function () {
  var _currTalk = new WeakMap();
  var _rpgs = new WeakMap();
  var _dialog = new WeakMap();

  return function () {
    function DialogWalker(rpgs) {
      _classCallCheck(this, DialogWalker);

      _rpgs.set(this, rpgs);
      _dialog.set(this, null);
      _currTalk.set(this, null);
    }

    _createClass(DialogWalker, [{
      key: 'reset',
      value: function reset() {
        var dialog = _dialog.get(this);
        if (dialog !== null) {
          this.setTalk(dialog.getStartTalk());
        }
      }
    }, {
      key: '_findNode',
      value: function _findNode(nodeId) {
        return _rpgs.get(this).findNode(nodeId);
      }
    }, {
      key: 'setDialog',
      value: function setDialog(dialogId) {
        var dialog = this._findNode(dialogId);
        if (dialog === null) {
          throw new Error('DialogNode with the id "' + dialogId + '" does not exists.');
        }
        _dialog.set(this, dialog);
        this.reset();
      }
    }, {
      key: 'setTalk',
      value: function setTalk(talkId) {
        console.log('setTalk', talkId);
        var talk = this._findNode(talkId);
        if (talk === null) {
          throw new Error('TalkNode with the id "' + talkId + '" does not exists.');
        }
        _currTalk.set(this, talk);
      }
    }, {
      key: 'getConversation',
      value: function getConversation() {
        var _this = this;

        var conversation = {};
        conversation.text = _currTalk.get(this).getText();
        var children = _currTalk.get(this).getChildren();
        conversation.options = children.map(function (answerId) {
          var answer = _this._findNode(answerId);
          return {
            id: answer.getId(),
            text: answer.getText(),
            isActive: answer.isActive(),
            isVisible: answer.isVisible()
          };
        });
        return conversation;
      }
    }, {
      key: 'selectOption',
      value: function selectOption(id) {
        var children = _currTalk.get(this).getChildren();
        var answerId = children.filter(function (currId, index, array) {
          return currId === id;
        });
        if (answerId[0] !== undefined) {
          var answerNode = this._findNode(answerId[0]);
          console.log('selectOption::answerNode', answerNode, answerNode.getId());
          if (answerNode !== null) this.setTalk(answerNode.getTalk());
        }
      }
    }]);

    return DialogWalker;
  }();
}();
module.exports = DialogWalker;

},{}],14:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Utils = require('../core/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _CompoundNode2 = require('../core/CompoundNode');

var _CompoundNode3 = _interopRequireDefault(_CompoundNode2);

var _Prop = require('../core/Prop');

var _Prop2 = _interopRequireDefault(_Prop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TalkNode = function () {

  var _text = new WeakMap();

  return function (_CompoundNode) {
    _inherits(TalkNode, _CompoundNode);

    function TalkNode(data, rpgs) {
      _classCallCheck(this, TalkNode);

      var _this = _possibleConstructorReturn(this, (TalkNode.__proto__ || Object.getPrototypeOf(TalkNode)).call(this, data, rpgs));

      _text.set(_this, data.text ? data.text : '');
      return _this;
    }

    _createClass(TalkNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(TalkNode.prototype.__proto__ || Object.getPrototypeOf(TalkNode.prototype), 'getData', this).call(this);
        data.text = this.getText();
        return data;
      }
    }, {
      key: 'setText',
      value: function setText(value) {
        _text.set(this, value);
      }
    }, {
      key: 'getText',
      value: function getText() {
        return _text.get(this);
      }
    }, {
      key: 'canAddChild',
      value: function canAddChild(type) {
        return type === 'AnswerNode';
      }
    }, {
      key: 'canSetWireType',
      value: function canSetWireType(type) {
        switch (type) {
          case _Prop2.default.GOTO:
            return true;
          default:
            return false;
        }
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _text.delete(this);
        _get(TalkNode.prototype.__proto__ || Object.getPrototypeOf(TalkNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return TalkNode;
  }(_CompoundNode3.default);
}();
module.exports = TalkNode;

},{"../core/CompoundNode":6,"../core/Prop":9,"../core/Utils":10}],15:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseNode2 = require('../core/BaseNode');

var _BaseNode3 = _interopRequireDefault(_BaseNode2);

var _Prop = require('../core/Prop');

var _Prop2 = _interopRequireDefault(_Prop);

var _nxCompile = require('@risingstack/nx-compile');

var _nxCompile2 = _interopRequireDefault(_nxCompile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ScriptNode = function () {
  var _label = new WeakMap();
  var _script = new WeakMap();
  var _compiled = new WeakMap();

  return function (_BaseNode) {
    _inherits(ScriptNode, _BaseNode);

    function ScriptNode(data, rpgs) {
      _classCallCheck(this, ScriptNode);

      var _this = _possibleConstructorReturn(this, (ScriptNode.__proto__ || Object.getPrototypeOf(ScriptNode)).call(this, data, rpgs));

      _label.set(_this, data.label ? data.label : '');
      _script.set(_this, data.script ? data.script : 'return true;');
      _nxCompile2.default.expose('console');
      _compiled.set(_this, _nxCompile2.default.compileCode(_script.get(_this)));
      return _this;
    }

    _createClass(ScriptNode, [{
      key: 'setLabel',
      value: function setLabel(text) {
        _label.set(this, text);
      }
    }, {
      key: 'getLabel',
      value: function getLabel() {
        return _label.get(this);
      }
    }, {
      key: 'setScript',
      value: function setScript(script) {
        _script.set(this, script);
        _compiled.set(this, _nxCompile2.default.compileCode(_script.get(this)));
      }
    }, {
      key: 'getScript',
      value: function getScript() {
        return _script.get(this);
      }
    }, {
      key: 'execute',
      value: function execute() {
        return _compiled.get(this)({ rpgs: this.getRPGS() });
      }
    }, {
      key: 'getData',
      value: function getData() {
        var data = _get(ScriptNode.prototype.__proto__ || Object.getPrototypeOf(ScriptNode.prototype), 'getData', this).call(this);
        data.label = this.getLabel();
        data.script = this.getScript();
        return data;
      }
    }, {
      key: 'setWire',
      value: function setWire(type, linkId) {}
    }, {
      key: 'getWires',
      value: function getWires(type) {}
    }, {
      key: 'removeWire',
      value: function removeWire(type, linkId) {}
    }, {
      key: 'dispose',
      value: function dispose() {
        _label.delete(this);
        _script.delete(this);
        _compiled.delete(this);
        _get(ScriptNode.prototype.__proto__ || Object.getPrototypeOf(ScriptNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return ScriptNode;
  }(_BaseNode3.default);
}();
module.exports = ScriptNode;

},{"../core/BaseNode":5,"../core/Prop":9,"@risingstack/nx-compile":1}],16:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CompoundNode2 = require('../core/CompoundNode');

var _CompoundNode3 = _interopRequireDefault(_CompoundNode2);

var _QuestStatus = require('./QuestStatus');

var _QuestStatus2 = _interopRequireDefault(_QuestStatus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_TASKS = 'tasks';

var QuestNode = function () {
  var _title = new WeakMap();
  var _description = new WeakMap();
  var _status = new WeakMap();

  return function (_CompoundNode) {
    _inherits(QuestNode, _CompoundNode);

    function QuestNode(data, rpgs) {
      _classCallCheck(this, QuestNode);

      var _this = _possibleConstructorReturn(this, (QuestNode.__proto__ || Object.getPrototypeOf(QuestNode)).call(this, data, rpgs));

      _title.set(_this, data.title ? data.title : '');
      _description.set(_this, data.description ? data.description : '');
      _status.set(_this, data.status ? data.status : _QuestStatus2.default.INCOMPLETE);
      return _this;
    }

    _createClass(QuestNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(QuestNode.prototype.__proto__ || Object.getPrototypeOf(QuestNode.prototype), 'getData', this).call(this);
        data.title = this.getTitle();
        data.description = this.getDescription();
        data.status = this.getStatus();
        return data;
      }
    }, {
      key: 'canAddChild',
      value: function canAddChild(type) {
        return type === 'TaskNode';
      }
    }, {
      key: 'setTitle',
      value: function setTitle(value) {
        _title.set(this, value);
      }
    }, {
      key: 'getTitle',
      value: function getTitle() {
        return _title.get(this);
      }
    }, {
      key: 'setDescription',
      value: function setDescription(value) {
        _description.set(this, value);
      }
    }, {
      key: 'getDescription',
      value: function getDescription() {
        return _description.get(this);
      }
    }, {
      key: 'setStatus',
      value: function setStatus(value) {
        switch (value) {
          case _QuestStatus2.default.COMPLETED:
          case _QuestStatus2.default.FAILED:
            _status.set(this, value);
          case _QuestStatus2.default.INCOMPLETE:
          default:
            _status.set(this, _QuestStatus2.default.INCOMPLETE);
            break;
        };
      }
    }, {
      key: 'getStatus',
      value: function getStatus() {
        return _status.get(this);
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _title.delete(this);
        _description.delete(this);
        _status.delete(this);
        _get(QuestNode.prototype.__proto__ || Object.getPrototypeOf(QuestNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return QuestNode;
  }(_CompoundNode3.default);
}();
module.exports = QuestNode;

},{"../core/CompoundNode":6,"./QuestStatus":17}],17:[function(require,module,exports){
"use strict";

var INCOMPLETE = 'questIncomplete';
var COMPLETED = 'questCompleted';
var FAILED = 'questFailed';

exports.INCOMPLETE = INCOMPLETE;
exports.COMPLETED = COMPLETED;
exports.FAILED = FAILED;

},{}],18:[function(require,module,exports){
"use strict";

var _BaseNode2 = require("../core/BaseNode");

var _BaseNode3 = _interopRequireDefault(_BaseNode2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TaskNode = function () {
  return function (_BaseNode) {
    _inherits(TaskNode, _BaseNode);

    function TaskNode(data) {
      _classCallCheck(this, TaskNode);

      return _possibleConstructorReturn(this, (TaskNode.__proto__ || Object.getPrototypeOf(TaskNode)).call(this, data));
    }

    //to do


    return TaskNode;
  }(_BaseNode3.default);
}();

module.exports = TaskNode;

},{"../core/BaseNode":5}],19:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _BaseNode2 = require('../core/BaseNode');

var _BaseNode3 = _interopRequireDefault(_BaseNode2);

var _VariableType = require('./VariableType');

var _VariableType2 = _interopRequireDefault(_VariableType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VariableNode = function () {
  var _value = new WeakMap();
  var _type = new WeakMap();

  function _parseBoolean(val) {
    var isBool = (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === _VariableType2.default.BOOLEAN;
    if (isBool) {
      return val;
    } else {
      switch (String(val).toLowerCase().trim()) {
        case "true":case "yes":case "1":
          return true;
        case "false":case "no":case "0":case null:
          return false;
        default:
          return Boolean(val);
      }
    }
  }

  function _parseString(val) {
    return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === _VariableType2.default.STRING ? val : String(val);
  }

  function _parseNumber(val) {
    return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === _VariableType2.default.NUMBER ? val : parseFloat(val);
  }

  function _parseValue(val, type) {
    switch (type) {
      case _VariableType2.default.BOOLEAN:
        return _parseBoolean(val);
      case _VariableType2.default.NUMBER:
        return _parseNumber(val);
      case _VariableType2.default.STRING:
      default:
        return _parseString(val);
    }
  }

  return function (_BaseNode) {
    _inherits(VariableNode, _BaseNode);

    function VariableNode(data, rpgs) {
      _classCallCheck(this, VariableNode);

      var _this = _possibleConstructorReturn(this, (VariableNode.__proto__ || Object.getPrototypeOf(VariableNode)).call(this, data, rpgs));

      _type.set(_this, data.hasOwnProperty('type') ? data.type : _VariableType2.default.STRING);
      _value.set(_this, data.hasOwnProperty('value') ? _parseValue(data.value, _type.get(_this)) : '');
      return _this;
    }

    _createClass(VariableNode, [{
      key: 'getData',
      value: function getData() {
        var data = _get(VariableNode.prototype.__proto__ || Object.getPrototypeOf(VariableNode.prototype), 'getData', this).call(this);
        data.type = this.getType();
        data.value = this.getValue();
        return data;
      }
    }, {
      key: 'setValue',
      value: function setValue(val) {
        _value.set(this, _parseValue(val, _type.get(this)));
      }
    }, {
      key: 'getValue',
      value: function getValue() {
        return _value.get(this);
      }
    }, {
      key: 'getType',
      value: function getType() {
        return _type.get(this);
      }
    }, {
      key: 'canSetWireType',
      value: function canSetWireType(type) {
        return false;
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        _value.delete(this);
        _type.delete(this);
        _get(VariableNode.prototype.__proto__ || Object.getPrototypeOf(VariableNode.prototype), 'dispose', this).call(this);
      }
    }]);

    return VariableNode;
  }(_BaseNode3.default);
}();

module.exports = VariableNode;

},{"../core/BaseNode":5,"./VariableType":20}],20:[function(require,module,exports){
'use strict';

var BOOLEAN = 'boolean';
var STRING = 'string';
var NUMBER = 'number';

exports.BOOLEAN = BOOLEAN;
exports.STRING = STRING;
exports.NUMBER = NUMBER;

},{}],21:[function(require,module,exports){
"use strict";

var _data = require('../data/data.json');

var _data2 = _interopRequireDefault(_data);

var _RPGSystem = require('./rpgs/RPGSystem');

var _RPGSystem2 = _interopRequireDefault(_RPGSystem);

var _DialogWalker = require('./rpgs/dialogs/DialogWalker');

var _DialogWalker2 = _interopRequireDefault(_DialogWalker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function ($, window, document, undefined) {
    $(function () {
        var rpgs1 = new _RPGSystem2.default();
        rpgs1.addActor('act1', { name: 'Adam' }).setWire('dialog', 'dlg1').addCondition('cond1', { script: 'return rpgs.getVar(\'b1\');' }).addDialog('dlg1', { startTalk: 'tlk0' }).addTalk('tlk0', { text: 'This is talk 0.' }).addAnswer('tlk0ans1', { text: 'Answer1' }).setWire('visibility', 'cond1').setWire('goto', 'tlk1').addAnswer('tlk0ans2', { text: 'Answer2' }).setWire('goto', 'tlk2').addAnswer('tlk0ans3', { text: 'Answer3' }).setWire('goto', 'tlk3').addTalk('tlk1', { text: 'This is talk 1.' }).addAnswer('tlk1ans1', { text: 'Answer1' }).addTalk('tlk2', { text: 'This is talk 2.' }).addAnswer('tlk2ans1', { text: 'Answer1' }).addTalk('tlk3', { text: 'This is talk 3.' }).addAnswer('tlk3ans1', { text: 'Answer1' }).addVariable('b1', { type: 'boolean', value: false }).addVariable('s1', { type: 'string', value: 'This is message from compiled code!' }).addVariable('n1', { type: 'number', value: 56 });
        var cond = rpgs1.getCondition('cond1');
        console.log(cond.execute());
        var b1 = rpgs1.getVariable('b1');
        var s1 = rpgs1.getVariable('s1');
        var n1 = rpgs1.getVariable('n1');

        var rpgs1Serialized = rpgs1.serializeData();
        console.log("rpgs1", rpgs1Serialized);

        var rpgs2 = new _RPGSystem2.default(JSON.parse(rpgs1Serialized));

        var rpgs2Serialized = rpgs2.serializeData();
        console.log("rpgs2", rpgs2Serialized);

        console.log("data created is equal to data parsed:", rpgs1Serialized === rpgs2Serialized);

        var walker = new _DialogWalker2.default(rpgs2);
        walker.setDialog('dlg1');
        console.log('conversation1:', walker.getConversation());
        walker.selectOption('tlk0ans1');
        console.log('conversation2:', walker.getConversation());
    });
})(jQuery, window, document);

},{"../data/data.json":2,"./rpgs/RPGSystem":3,"./rpgs/dialogs/DialogWalker":13}]},{},[21])


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHJpc2luZ3N0YWNrL254LWNvbXBpbGUvY29tcGlsZXIuanMiLCJzcmMvZGF0YS9kYXRhLmpzb24iLCJzcmMvanMvcnBncy9SUEdTeXN0ZW0uanMiLCJzcmMvanMvcnBncy9hY3RvcnMvQWN0b3JOb2RlLmpzIiwic3JjL2pzL3JwZ3MvY29yZS9CYXNlTm9kZS5qcyIsInNyYy9qcy9ycGdzL2NvcmUvQ29tcG91bmROb2RlLmpzIiwic3JjL2pzL3JwZ3MvY29yZS9FcnJvckNvZGUuanMiLCJzcmMvanMvcnBncy9jb3JlL0Vycm9ySGFuZGxlci5qcyIsInNyYy9qcy9ycGdzL2NvcmUvUHJvcC5qcyIsInNyYy9qcy9ycGdzL2NvcmUvVXRpbHMuanMiLCJzcmMvanMvcnBncy9kaWFsb2dzL0Fuc3dlck5vZGUuanMiLCJzcmMvanMvcnBncy9kaWFsb2dzL0RpYWxvZ05vZGUuanMiLCJzcmMvanMvcnBncy9kaWFsb2dzL0RpYWxvZ1dhbGtlci5qcyIsInNyYy9qcy9ycGdzL2RpYWxvZ3MvVGFsa05vZGUuanMiLCJzcmMvanMvcnBncy9sb2dpYy9TY3JpcHROb2RlLmpzIiwic3JjL2pzL3JwZ3MvcXVlc3RzL1F1ZXN0Tm9kZS5qcyIsInNyYy9qcy9ycGdzL3F1ZXN0cy9RdWVzdFN0YXR1cy5qcyIsInNyYy9qcy9ycGdzL3F1ZXN0cy9UYXNrTm9kZS5qcyIsInNyYy9qcy9ycGdzL3ZhcmlhYmxlcy9WYXJpYWJsZU5vZGUuanMiLCJzcmMvanMvcnBncy92YXJpYWJsZXMvVmFyaWFibGVUeXBlLmpzIiwic3JjL2pzL3NjcmlwdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVksT0FBWixFQUFvQixlQUFwQjs7QUFFQSxnQkFBUSxHQUFSLENBQVksdUNBQVosRUFBb0Qsb0JBQW9CLGVBQXhFOztBQUVBLFlBQUksU0FBUywyQkFBaUIsS0FBakIsQ0FBYjtBQUNBLGVBQU8sU0FBUCxDQUFpQixNQUFqQjtBQUNBLGdCQUFRLEdBQVIsQ0FBWSxnQkFBWixFQUE2QixPQUFPLGVBQVAsRUFBN0I7QUFDQSxlQUFPLFlBQVAsQ0FBb0IsVUFBcEI7QUFDQSxnQkFBUSxHQUFSLENBQVksZ0JBQVosRUFBNkIsT0FBTyxlQUFQLEVBQTdCO0FBQ0QsS0E1Q0Q7QUE4Q0QsQ0EvQ0QsRUErQ0csTUEvQ0gsRUErQ1csTUEvQ1gsRUErQ21CLFFBL0NuQiIsImZpbGUiOiJzY3JpcHRzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21waWxlQ29kZSxcbiAgY29tcGlsZUV4cHJlc3Npb24sXG4gIGV4cG9zZSxcbiAgaGlkZVxufVxuXG5sZXQgZ2xvYmFsT2JqXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbE9iaiA9IHdpbmRvdyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5lbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsT2JqID0gZ2xvYmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsT2JqID0gc2VsZiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5nbG9iYWxPYmouJG54Q29tcGlsZVRvU2FuZGJveCA9IHRvU2FuZGJveFxuZ2xvYmFsT2JqLiRueENvbXBpbGVDcmVhdGVCYWNrdXAgPSBjcmVhdGVCYWNrdXBcblxuY29uc3QgcHJveGllcyA9IG5ldyBXZWFrTWFwKClcbmNvbnN0IGV4cHJlc3Npb25DYWNoZSA9IG5ldyBNYXAoKVxuY29uc3QgY29kZUNhY2hlID0gbmV3IE1hcCgpXG5jb25zdCBnbG9iYWxzID0gbmV3IFNldCgpXG5jb25zdCBoYW5kbGVycyA9IHtoYXN9XG5cbmZ1bmN0aW9uIGNvbXBpbGVFeHByZXNzaW9uIChzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpXG4gIH1cbiAgbGV0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uQ2FjaGUuZ2V0KHNyYylcbiAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgZXhwcmVzc2lvbiA9IG5ldyBGdW5jdGlvbignY29udGV4dCcsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGBjb25zdCBzYW5kYm94ID0gJG54Q29tcGlsZVRvU2FuZGJveChjb250ZXh0KVxuICAgICAgdHJ5IHsgd2l0aCAoc2FuZGJveCkgeyByZXR1cm4gJHtzcmN9IH0gfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikpIHRocm93IGVyclxuICAgICAgfWApXG4gICAgZXhwcmVzc2lvbkNhY2hlLnNldChzcmMsIGV4cHJlc3Npb24pXG4gIH1cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvZGUgKHNyYykge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgfVxuICBsZXQgY29kZSA9IGNvZGVDYWNoZS5nZXQoc3JjKVxuICBpZiAoIWNvZGUpIHtcbiAgICBjb2RlID0gbmV3IEZ1bmN0aW9uKCdjb250ZXh0JywgJ3RlbXBWYXJzJywgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGBjb25zdCBiYWNrdXAgPSAkbnhDb21waWxlQ3JlYXRlQmFja3VwKGNvbnRleHQsIHRlbXBWYXJzKVxuICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwgdGVtcFZhcnMpXG4gICAgY29uc3Qgc2FuZGJveCA9ICRueENvbXBpbGVUb1NhbmRib3goY29udGV4dClcbiAgICB0cnkge1xuICAgICAgd2l0aCAoc2FuZGJveCkgeyAke3NyY30gfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBPYmplY3QuYXNzaWduKGNvbnRleHQsIGJhY2t1cClcbiAgICB9YClcbiAgICBjb2RlQ2FjaGUuc2V0KHNyYywgY29kZSlcbiAgfVxuICByZXR1cm4gY29kZVxufVxuXG5mdW5jdGlvbiBleHBvc2UgKC4uLmdsb2JhbE5hbWVzKSB7XG4gIGZvciAobGV0IGdsb2JhbE5hbWUgb2YgZ2xvYmFsTmFtZXMpIHtcbiAgICBnbG9iYWxzLmFkZChnbG9iYWxOYW1lKVxuICB9XG59XG5cbmZ1bmN0aW9uIGhpZGUgKC4uLmdsb2JhbE5hbWVzKSB7XG4gIGZvciAobGV0IGdsb2JhbE5hbWUgb2YgZ2xvYmFsTmFtZXMpIHtcbiAgICBnbG9iYWxzLmRlbGV0ZShnbG9iYWxOYW1lKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvU2FuZGJveCAob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0JylcbiAgfVxuICBsZXQgc2FuZGJveCA9IHByb3hpZXMuZ2V0KG9iailcbiAgaWYgKCFzYW5kYm94KSB7XG4gICAgc2FuZGJveCA9IG5ldyBQcm94eShvYmosIGhhbmRsZXJzKVxuICAgIHByb3hpZXMuc2V0KG9iaiwgc2FuZGJveClcbiAgfVxuICByZXR1cm4gc2FuZGJveFxufVxuXG5mdW5jdGlvbiBjcmVhdGVCYWNrdXAgKGNvbnRleHQsIHRlbXBWYXJzKSB7XG4gIGlmICh0eXBlb2YgdGVtcFZhcnMgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgYmFja3VwID0ge31cbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGVtcFZhcnMpKSB7XG4gICAgICBiYWNrdXBba2V5XSA9IGNvbnRleHRba2V5XVxuICAgIH1cbiAgICByZXR1cm4gYmFja3VwXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICByZXR1cm4gZ2xvYmFscy5oYXMoa2V5KSA/IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KSA6IHRydWVcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcImFjdG9yc1wiOlt7XCJjbGFzc1wiOlwiQWN0b3JOb2RlXCIsXCJ1dWlkXCI6XCJhY3QxXCIsXCJpbnB1dFwiOntcImRpYWxvZ1wiOltcIjJkOTFlNjc1LTljMmQtNDhkOS04N2QwLWIwMjYwYjQwMzA1OVwiXX0sXCJuYW1lXCI6XCJBZGFtXCJ9XSxcImxvZ2ljXCI6W3tcImNsYXNzXCI6XCJTY3JpcHROb2RlXCIsXCJ1dWlkXCI6XCJjb25kMVwiLFwib3V0cHV0XCI6e1widmlzaWJpbGl0eVwiOltcImM5NGI0ZjFkLTIxMTQtNDNiYS1iOWIxLWY0NWZiMDI2ZTA3ZlwiXX0sXCJsYWJlbFwiOlwiXCIsXCJzY3JpcHRcIjpcInJldHVybiAyPjEgJiYgcnBncy5nZXRWYXIoJ2IxJykgPT09IGZhbHNlO1wifV0sXCJkaWFsb2dzXCI6W3tcImNsYXNzXCI6XCJEaWFsb2dOb2RlXCIsXCJ1dWlkXCI6XCJkbGcxXCIsXCJpbnB1dFwiOnt9LFwib3V0cHV0XCI6e1wiZGlhbG9nXCI6W1wiMmQ5MWU2NzUtOWMyZC00OGQ5LTg3ZDAtYjAyNjBiNDAzMDU5XCJdfSxcImNoaWxkcmVuXCI6W1widGxrMFwiLFwidGxrMVwiLFwidGxrMlwiLFwidGxrM1wiXSxcInN0YXJ0VGFsa1wiOlwidGxrMFwifV0sXCJsaW5rc1wiOlt7XCJjbGFzc1wiOlwiTGlua05vZGVcIixcInV1aWRcIjpcIjJkOTFlNjc1LTljMmQtNDhkOS04N2QwLWIwMjYwYjQwMzA1OVwiLFwiaW5wdXRcIjpcImFjdDFcIixcIm91dHB1dFwiOlwiZGxnMVwiLFwidHlwZVwiOlwiZGlhbG9nXCJ9LHtcImNsYXNzXCI6XCJMaW5rTm9kZVwiLFwidXVpZFwiOlwiYzk0YjRmMWQtMjExNC00M2JhLWI5YjEtZjQ1ZmIwMjZlMDdmXCIsXCJpbnB1dFwiOlwidGxrMGFuczFcIixcIm91dHB1dFwiOlwiY29uZDFcIixcInR5cGVcIjpcInZpc2liaWxpdHlcIn0se1wiY2xhc3NcIjpcIkxpbmtOb2RlXCIsXCJ1dWlkXCI6XCIzMTg0NjczZi0wNmU2LTQxZGMtYWM3Mi04OWIyZTU4ZTM4MDNcIixcImlucHV0XCI6XCJ0bGsxXCIsXCJvdXRwdXRcIjpcInRsazBhbnMxXCIsXCJ0eXBlXCI6XCJnb3RvXCJ9LHtcImNsYXNzXCI6XCJMaW5rTm9kZVwiLFwidXVpZFwiOlwiMGZiMWQ2NmEtYjNlNy00OWFmLWI4MDItMTI1MjkxMTU5NjViXCIsXCJpbnB1dFwiOlwidGxrMlwiLFwib3V0cHV0XCI6XCJ0bGswYW5zMlwiLFwidHlwZVwiOlwiZ290b1wifSx7XCJjbGFzc1wiOlwiTGlua05vZGVcIixcInV1aWRcIjpcIjkyZjlmYjc5LWYyMWEtNGJmOC1iZmE0LTdiMWJiZmM2NGI3Y1wiLFwiaW5wdXRcIjpcInRsazNcIixcIm91dHB1dFwiOlwidGxrMGFuczNcIixcInR5cGVcIjpcImdvdG9cIn1dLFwidGFsa3NcIjpbe1wiY2xhc3NcIjpcIlRhbGtOb2RlXCIsXCJ1dWlkXCI6XCJ0bGswXCIsXCJpbnB1dFwiOnt9LFwiY2hpbGRyZW5cIjpbXCJ0bGswYW5zMVwiLFwidGxrMGFuczJcIixcInRsazBhbnMzXCJdLFwidGV4dFwiOlwiVGhpcyBpcyB0YWxrIDAuXCJ9LHtcImNsYXNzXCI6XCJUYWxrTm9kZVwiLFwidXVpZFwiOlwidGxrMVwiLFwiaW5wdXRcIjp7XCJnb3RvXCI6W1wiMzE4NDY3M2YtMDZlNi00MWRjLWFjNzItODliMmU1OGUzODAzXCJdfSxcImNoaWxkcmVuXCI6W1widGxrMWFuczFcIl0sXCJ0ZXh0XCI6XCJUaGlzIGlzIHRhbGsgMS5cIn0se1wiY2xhc3NcIjpcIlRhbGtOb2RlXCIsXCJ1dWlkXCI6XCJ0bGsyXCIsXCJpbnB1dFwiOntcImdvdG9cIjpbXCIwZmIxZDY2YS1iM2U3LTQ5YWYtYjgwMi0xMjUyOTExNTk2NWJcIl19LFwiY2hpbGRyZW5cIjpbXCJ0bGsyYW5zMVwiXSxcInRleHRcIjpcIlRoaXMgaXMgdGFsayAyLlwifSx7XCJjbGFzc1wiOlwiVGFsa05vZGVcIixcInV1aWRcIjpcInRsazNcIixcImlucHV0XCI6e1wiZ290b1wiOltcIjkyZjlmYjc5LWYyMWEtNGJmOC1iZmE0LTdiMWJiZmM2NGI3Y1wiXX0sXCJjaGlsZHJlblwiOltcInRsazNhbnMxXCJdLFwidGV4dFwiOlwiVGhpcyBpcyB0YWxrIDMuXCJ9XSxcImFuc3dlcnNcIjpbe1wiY2xhc3NcIjpcIkFuc3dlck5vZGVcIixcInV1aWRcIjpcInRsazBhbnMxXCIsXCJpbnB1dFwiOntcInZpc2liaWxpdHlcIjpbXCJjOTRiNGYxZC0yMTE0LTQzYmEtYjliMS1mNDVmYjAyNmUwN2ZcIl19LFwib3V0cHV0XCI6e1wiZ290b1wiOltcIjMxODQ2NzNmLTA2ZTYtNDFkYy1hYzcyLTg5YjJlNThlMzgwM1wiXX0sXCJ0ZXh0XCI6XCJBbnN3ZXIxXCJ9LHtcImNsYXNzXCI6XCJBbnN3ZXJOb2RlXCIsXCJ1dWlkXCI6XCJ0bGswYW5zMlwiLFwiaW5wdXRcIjp7fSxcIm91dHB1dFwiOntcImdvdG9cIjpbXCIwZmIxZDY2YS1iM2U3LTQ5YWYtYjgwMi0xMjUyOTExNTk2NWJcIl19LFwidGV4dFwiOlwiQW5zd2VyMlwifSx7XCJjbGFzc1wiOlwiQW5zd2VyTm9kZVwiLFwidXVpZFwiOlwidGxrMGFuczNcIixcImlucHV0XCI6e30sXCJvdXRwdXRcIjp7XCJnb3RvXCI6W1wiOTJmOWZiNzktZjIxYS00YmY4LWJmYTQtN2IxYmJmYzY0YjdjXCJdfSxcInRleHRcIjpcIkFuc3dlcjNcIn0se1wiY2xhc3NcIjpcIkFuc3dlck5vZGVcIixcInV1aWRcIjpcInRsazFhbnMxXCIsXCJpbnB1dFwiOnt9LFwib3V0cHV0XCI6e30sXCJ0ZXh0XCI6XCJBbnN3ZXIxXCJ9LHtcImNsYXNzXCI6XCJBbnN3ZXJOb2RlXCIsXCJ1dWlkXCI6XCJ0bGsyYW5zMVwiLFwiaW5wdXRcIjp7fSxcIm91dHB1dFwiOnt9LFwidGV4dFwiOlwiQW5zd2VyMVwifSx7XCJjbGFzc1wiOlwiQW5zd2VyTm9kZVwiLFwidXVpZFwiOlwidGxrM2FuczFcIixcImlucHV0XCI6e30sXCJvdXRwdXRcIjp7fSxcInRleHRcIjpcIkFuc3dlcjFcIn1dLFwidmFyaWFibGVzXCI6W3tcImNsYXNzXCI6XCJWYXJpYWJsZU5vZGVcIixcInV1aWRcIjpcImIxXCIsXCJpbnB1dFwiOnt9LFwib3V0cHV0XCI6e30sXCJ0eXBlXCI6XCJib29sZWFuXCIsXCJ2YWx1ZVwiOmZhbHNlfSx7XCJjbGFzc1wiOlwiVmFyaWFibGVOb2RlXCIsXCJ1dWlkXCI6XCJzMVwiLFwiaW5wdXRcIjp7fSxcIm91dHB1dFwiOnt9LFwidHlwZVwiOlwic3RyaW5nXCIsXCJ2YWx1ZVwiOlwiVGhpcyBpcyBtZXNzYWdlIGZyb20gY29tcGlsZWQgY29kZSFcIn0se1wiY2xhc3NcIjpcIlZhcmlhYmxlTm9kZVwiLFwidXVpZFwiOlwibjFcIixcImlucHV0XCI6e30sXCJvdXRwdXRcIjp7fSxcInR5cGVcIjpcIm51bWJlclwiLFwidmFsdWVcIjo1Nn1dfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCBVdGlscyAgICAgICAgICAgIGZyb20gJy4vY29yZS9VdGlscyc7XHJcbmltcG9ydCBFcnJvckhhbmRsZXIgICAgIGZyb20gJy4vY29yZS9FcnJvckhhbmRsZXInXHJcbmltcG9ydCBFcnJvckNvZGUgICAgICAgIGZyb20gJy4vY29yZS9FcnJvckNvZGUnO1xyXG5pbXBvcnQgQmFzZU5vZGUgICAgICAgICBmcm9tICcuL2NvcmUvQmFzZU5vZGUnO1xyXG5pbXBvcnQgQWN0b3JOb2RlICAgICAgICBmcm9tICcuL2FjdG9ycy9BY3Rvck5vZGUnO1xyXG4vL2ltcG9ydCBJbnZlbnRvcnlOb2RlICBmcm9tICcuL2FjdG9ycy9JbnZlbnRvcnlOb2RlJztcclxuaW1wb3J0IFNjcmlwdE5vZGUgICAgICAgZnJvbSAnLi9sb2dpYy9TY3JpcHROb2RlJztcclxuaW1wb3J0IEFuc3dlck5vZGUgICAgICAgZnJvbSAnLi9kaWFsb2dzL0Fuc3dlck5vZGUnO1xyXG5pbXBvcnQgRGlhbG9nTm9kZSAgICAgICBmcm9tICcuL2RpYWxvZ3MvRGlhbG9nTm9kZSc7XHJcbmltcG9ydCBUYWxrTm9kZSAgICAgICAgIGZyb20gJy4vZGlhbG9ncy9UYWxrTm9kZSc7XHJcbmltcG9ydCBRdWVzdE5vZGUgICAgICAgIGZyb20gJy4vcXVlc3RzL1F1ZXN0Tm9kZSc7XHJcbmltcG9ydCBUYXNrTm9kZSAgICAgICAgIGZyb20gJy4vcXVlc3RzL1Rhc2tOb2RlJztcclxuaW1wb3J0IFZhcmlhYmxlTm9kZSAgICAgZnJvbSAnLi92YXJpYWJsZXMvVmFyaWFibGVOb2RlJztcclxuXHJcbmNvbnN0IEtFWV9BQ1RPUlMgPSAnYWN0b3JzJztcclxuY29uc3QgS0VZX0FOU1dFUlMgPSAnYW5zd2Vycyc7XHJcbmNvbnN0IEtFWV9MT0dJQyA9ICdsb2dpYyc7XHJcbmNvbnN0IEtFWV9ESUFMT0dTID0gJ2RpYWxvZ3MnO1xyXG5jb25zdCBLRVlfTElOS1MgPSAnbGlua3MnO1xyXG5jb25zdCBLRVlfU0NSSVBUUyA9ICdzY3JpcHRzJztcclxuY29uc3QgS0VZX1RBTEtTID0gJ3RhbGtzJztcclxuY29uc3QgS0VZX1RBU0tTID0gJ3Rhc2tzJztcclxuY29uc3QgS0VZX1FVRVNUUyA9ICdxdWVzdHMnO1xyXG5jb25zdCBLRVlfVkFSSUFCTEVTID0gJ3ZhcmlhYmxlcyc7XHJcblxyXG5sZXQgUlBHU3lzdGVtID0gZnVuY3Rpb24gKGRhdGEsZWRpdG9yKSB7XHJcbiAgbGV0IF9vYmplY3RQb29sID0ge30sXHJcbiAgX2VkaXRvciA9IGVkaXRvcnx8bnVsbCxcclxuICBfZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcihfZWRpdG9yKSxcclxuICBfY29udGV4dCA9IG51bGwsXHJcbiAgX2xhc3RDaGlsZCA9IG51bGwsXHJcbiAgX3BhcmVudEhpc3RvcnkgPSBbXSxcclxuICBfdGVtcFdpcmVzID0gW107XHJcblxyXG4gIGZ1bmN0aW9uIF9ub2RlRmFjdG9yeShkYXRhLHJwZ3MpIHtcclxuICAgIGxldCBjbGFzc05hbWUgPSBkYXRhLmNsYXNzO1xyXG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcclxuICAgICAgY2FzZSAnQWN0b3JOb2RlJzogICAgIHJldHVybiBuZXcgQWN0b3JOb2RlKGRhdGEscnBncyk7XHJcbiAgICAgIGNhc2UgJ1NjcmlwdE5vZGUnOiAgICByZXR1cm4gbmV3IFNjcmlwdE5vZGUoZGF0YSxycGdzKTtcclxuICAgICAgY2FzZSAnQW5zd2VyTm9kZSc6ICAgIHJldHVybiBuZXcgQW5zd2VyTm9kZShkYXRhLHJwZ3MpO1xyXG4gICAgICBjYXNlICdEaWFsb2dOb2RlJzogICAgcmV0dXJuIG5ldyBEaWFsb2dOb2RlKGRhdGEscnBncyk7XHJcbiAgICAgIGNhc2UgJ1RhbGtOb2RlJzogICAgICByZXR1cm4gbmV3IFRhbGtOb2RlKGRhdGEscnBncyk7XHJcbiAgICAgIGNhc2UgJ1F1ZXN0Tm9kZSc6ICAgICByZXR1cm4gbmV3IFF1ZXN0Tm9kZShkYXRhLHJwZ3MpO1xyXG4gICAgICBjYXNlICdUYXNrTm9kZSc6ICAgICAgcmV0dXJuIG5ldyBUYXNrTm9kZShkYXRhLHJwZ3MpO1xyXG4gICAgICAvL2Nhc2UgJ0xpbmtOb2RlJzogICAgICByZXR1cm4gbmV3IExpbmtOb2RlKGRhdGEscnBncyk7XHJcbiAgICAgIGNhc2UgJ1ZhcmlhYmxlTm9kZSc6ICByZXR1cm4gbmV3IFZhcmlhYmxlTm9kZShkYXRhLHJwZ3MpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIF9lcnJvckhhbmRsZXIuc2hvd01zZyhFcnJvckNvZGUuQ0xBU1NfTk9UX0RFRklORUQse2NsYXNzOmNsYXNzTmFtZX0pO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2ZpbmROb2RlSW5BcnJheShhcnJheSxpZCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZihhcnJheVtpXS5nZXRJZCgpID09PSBpZCkgcmV0dXJuIGFycmF5W2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBsZXQgX2ZpbmROb2RlID0gZnVuY3Rpb24ob2JqSWQpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBfb2JqZWN0UG9vbCkge1xyXG4gICAgICBpZiAoX29iamVjdFBvb2wuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIGxldCBvYmogPSBfZmluZE5vZGVJbkFycmF5KF9vYmplY3RQb29sW2tleV0sb2JqSWQpO1xyXG4gICAgICAgIGlmKG9iaiAhPT0gbnVsbCkgcmV0dXJuIG9iajtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9JcyBlcnJvciBtZXNzYWdlIG5lY2Nlc3NhcnkgaGVyZT8gVG8gY29uc2lkZXIuXHJcbiAgICAvL19lcnJvckhhbmRsZXIuc2hvd01zZyhFcnJvckNvZGUuT0JKRUNUX05PVF9GT1VORCx7aWQ6b2JqSWR9KTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxuICBfYWRkTm9kZSA9IGZ1bmN0aW9uKGtleSxvYmopIHtcbiAgICBpZighX29iamVjdFBvb2xba2V5XSkgX29iamVjdFBvb2xba2V5XSA9IFtdO1xyXG4gICAgX29iamVjdFBvb2xba2V5XS5wdXNoKG9iaik7XHJcbiAgfSxcclxuXHJcbiAgX3JlbW92ZU5vZGUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIF9vYmplY3RQb29sKSB7XHJcbiAgICAgIGlmIChfb2JqZWN0UG9vbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgaWYodGhpcy5fcmVtb3ZlTm9kZUJ5S2V5KGtleSxpZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgX3JlbW92ZU5vZGVCeUtleSA9IGZ1bmN0aW9uKGtleSxpZCkge1xyXG4gICAgbGV0IGluZGV4ID0gVXRpbHMuZ2V0SW5kZXhCeUlkKF9vYmplY3RQb29sW2tleV0saWQpO1xyXG4gICAgbGV0IGlzTm9kZUZvdW5kID0gaW5kZXggPiAtMTtcclxuICAgIGlmKGlzTm9kZUZvdW5kKSB7XHJcbiAgICAgIGxldCBub2RlID0gX29iamVjdFBvb2xba2V5XS5zcGxpY2UoaW5kZXgsMSlbMF07XHJcbiAgICAgIG5vZGUuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzTm9kZUZvdW5kO1xyXG4gIH0sXHJcblxyXG4gIF9zZXRDb25uZWN0aW9uID0gZnVuY3Rpb24odHlwZSxub2RlSWQxLG5vZGVJZDIpIHtcclxuICAgIGlmKG5vZGVJZDEgPT09IG5vZGVJZDIpIHtcclxuICAgICAgX2Vycm9ySGFuZGxlci5zaG93TXNnKEVycm9yQ29kZS5DT05ORUNUSU9OX1RPX0lUU0VMRix7bm9kZTpub2RlSWQxfSk7XHJcbiAgICB9XHJcbiAgICBsZXQgbm9kZTEgPSBfZmluZE5vZGUobm9kZUlkMSk7XHJcbiAgICBsZXQgbm9kZTIgPSBfZmluZE5vZGUobm9kZUlkMik7XHJcbiAgICBpZihub2RlMiA9PT0gbnVsbCkge1xyXG4gICAgICBjb25zb2xlLmxvZygncnBnczo6dGVtcFdpcmUnLHR5cGUsbm9kZUlkMSxub2RlSWQyKTtcclxuICAgICAgX3RlbXBXaXJlcy5wdXNoKHt0eXBlOnR5cGUsdGFyZ2V0Tm9kZTpub2RlSWQxLHJlZmVyZW5jZU5vZGU6bm9kZUlkMn0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZihub2RlMS5jYW5TZXRXaXJlVHlwZSh0eXBlKSkge1xyXG4gICAgICBjb25zb2xlLmxvZygncnBnczo6Y3JlYXRlV2lyZScsdHlwZSxub2RlSWQxLG5vZGVJZDIpO1xyXG4gICAgICBub2RlMS5zZXRXaXJlKHR5cGUsbm9kZTIuZ2V0SWQoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfZXJyb3JIYW5kbGVyLnNob3dNc2coRXJyb3JDb2RlLklNUFJPUEVSX0NPTk5FQ1RJT04se1xyXG4gICAgICAgIHR5cGU6dHlwZSxcclxuICAgICAgICBub2RlMTpub2RlSWQxLFxyXG4gICAgICAgIG5vZGUyOm5vZGVJZDJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vTUVUSE9EIENIQUlOSU5HXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAvKipcclxuICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayBwYXNzZWQgcGFyYW1ldGVycyBhbmQgbGF0ZXIgbWVyZ2UgdGhlbSBpbnRvXHJcbiAgICogc2luZ2xlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICAgICAgTWFuZGF0b3J5IGlkIG9mIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgIE9wdGlvbmFsIHBhcmFtZXRlcnMuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBQYXJhbWV0ZXJzIG1lcmdlZCBpbnRvIG9iamVjdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfY2hlY2tBbmRNZXJnZVBhcmFtcyhcclxuICAgICAgICAgICAgICAgIGlkID0gX2Vycm9ySGFuZGxlci5zaG93TXNnKEVycm9yQ29kZS5NQU5EQVRPUllfUEFSQU0se3BhcmFtOidpZCd9KSxcclxuICAgICAgICAgICAgICAgIHBhcmFtcykge1xyXG4gICAgICBpZih0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgX2Vycm9ySGFuZGxlci5zaG93TXNnKEVycm9yQ29kZS5JTkNPUlJFQ1RfVFlQRSx7dHlwZTonc3RyaW5nJ30pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgX2Vycm9ySGFuZGxlci5zaG93TXNnKEVycm9yQ29kZS5JTkNPUlJFQ1RfVFlQRSx7dHlwZTonb2JqZWN0J30pO1xyXG4gICAgICB9IGVsc2UgaWYocGFyYW1zID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHBhcmFtcyA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmFtcy51dWlkID0gaWQ7XHJcbiAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBoZWxwcyBpbiB0aGUgY3JlYXRpb24gb2Ygbm9kZXMuIEl0cyBmb2N1cyBvbiBwcm9wZXJcclxuICAgKiBwbGFjZW1lbnQgb2Ygbm9kZXMgaW4gdHJlZS5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICAgICAgTWFuZGF0b3J5IGlkIG9mIG5ld2x5IGNyZWF0ZWQgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgUGFyYW1ldGVycyBvZiBjcmVhdGVkIG5vZGUuXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gYXNDaGlsZCBEZXRlcm1pbmVzIGlmIG5vZGUgc2hvdWxkIGJlIGFkZGVkIGFzIGNoaWxkXHJcbiAgICogb2YgYW5vdGhlciBub2RlIG9yIGFzIGFuIGluZGVwZW5kZW50IG5vZGUuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjbGFzc05hbWUgICBOYW1lIG9mIGNsYXNzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc3RvcmFnZSBOYW1lIG9mIG5vZGUgZ3JvdXAgaW5zaWRlIHdoaWNoIG5vZGUgd2lsbCBiZSBhZGRlZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfY2hhaW5Ob2RlQ3JlYXRvcihpZCxwYXJhbXMsYXNDaGlsZCxjbGFzc05hbWUsc3RvcmFnZSkge1xyXG4gICAgLy9GaXJzdCwgd2UgY2hlY2sgdGhhdCBpZCBhbmQgcGFyYW1zIGFyZSB2YWxpZC5cclxuICAgIHBhcmFtcyA9IF9jaGVja0FuZE1lcmdlUGFyYW1zKGlkLHBhcmFtcyk7XHJcbiAgICAvL0NsYXNzIG5hbWUgZm9yIGxhdGVyIHVzYWdlLlxyXG4gICAgcGFyYW1zLmNsYXNzID0gY2xhc3NOYW1lO1xyXG5cclxuICAgIC8vVGVzdCBpZiBub2RlIHNob3VsZCBiZSBhZGRlZCBhcyBjaGlsZCBvciBwYXJlbnQuXHJcbiAgICBpZihhc0NoaWxkKSB7XHJcbiAgICAgIC8vSWYgbGFzdCBhZGRlZCBjaGlsZCB3YXMgbm90IG51bGwgdGhlbiB3ZSBtdXN0IGNoZWNrIGFkZGl0aW9uYWwgY29uZGl0aW9ucy5cclxuICAgICAgaWYoX2xhc3RDaGlsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vSWYgY29uc3RydWN0b3IgbmFtZSBvZiBwcmV2aW91cyBjaGlsZCBub2RlLCBpcyBlcXVhbCB0byBuYW1lIG9mIGNsYXNzLFxyXG4gICAgICAgIC8vd2hvc2Ugd2UgdHJ5IHRvIGNyZWF0ZSwgaXQgbWVhbnMgbm9kZSBzaG91bGQgYmUgYWRkZWQgdG8gY3VycmVudCBwYXJlbnQuXHJcbiAgICAgICAgaWYoX2xhc3RDaGlsZC5jb25zdHJ1Y3Rvci5uYW1lID09PSBjbGFzc05hbWUpIHtcclxuICAgICAgICAgIGNyZWF0ZUNoaWxkTm9kZShwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0lmIG5hbWVzIG9mIGNvbnN0cnVjdG9ycyBub3QgbWF0Y2gsIHRoZW4gd2UgbXVzdCBjaGVjayBpZiBuZXcgbm9kZVxyXG4gICAgICAgIC8vY2FuIGJlIGFkZGVkIGFzIGNoaWxkIHRvIG91ciBwcmV2aW91cyBjaGlsZC5cclxuICAgICAgICBlbHNlIGlmKF9sYXN0Q2hpbGQuY2FuQWRkQ2hpbGQoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgX3BhcmVudEhpc3RvcnkudW5zaGlmdChfbGFzdENoaWxkKTtcclxuICAgICAgICAgIGNyZWF0ZUNoaWxkTm9kZShwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0ZpbmFsbHkgaWYgcHJldmlvdXMgY29uZGl0aW9ucyBhcmUgZmFsc2Ugd2UgdHJ5IGdvIGJhY2sgdG8gcHJldmlvdXNcclxuICAgICAgICAvL3BhcmVudCBub2RlLlxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgX2xhc3RDaGlsZCA9IF9wYXJlbnRIaXN0b3J5LnNoaWZ0KCl8fG51bGw7XHJcbiAgICAgICAgICBfY2hhaW5Ob2RlQ3JlYXRvcihpZCxwYXJhbXMsYXNDaGlsZCxjbGFzc05hbWUsc3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vSWYgbGFzdCBjaGlsZCBpcyBudWxsLCB0aGVuIHdlIGNoZWNrIGlmIG5vZGUgY2FuIGJlIGFkZGVkIHRvIGN1cnJlbnRcclxuICAgICAgLy9wYXJlbnQgbm9kZS5cclxuICAgICAgZWxzZSBpZihfcGFyZW50SGlzdG9yeS5sZW5ndGggPiAwICYmIF9wYXJlbnRIaXN0b3J5WzBdLmNhbkFkZENoaWxkKGNsYXNzTmFtZSkpIHtcclxuICAgICAgICBjcmVhdGVDaGlsZE5vZGUocGFyYW1zKTtcclxuICAgICAgfVxyXG4gICAgICAvL0lmIGxhc3QgY2hpbGQgYW5kIGxhc3QgcGFyZW50IGlzIGVxdWFsIHRvIG51bGwsIHRoZW4gbmV3IGNoaWxkIG5vZGVcclxuICAgICAgLy9jYW50IGJlIGFkZGVkLCBzbyB3ZSB0aHJvdyBlcnJvci5cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgX2Vycm9ySGFuZGxlci5zaG93TXNnKEVycm9yQ29kZS5JTkNPTVBBVElCTEVfQ0hJTEQse1xyXG4gICAgICAgICAgY2hpbGQ6Y2xhc3NOYW1lLFxyXG4gICAgICAgICAgcGFyZW50OiBfcGFyZW50SGlzdG9yeS5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgICAgICA/IF9wYXJlbnRIaXN0b3J5WzBdLmNvbnN0cnVjdG9yLm5hbWVcclxuICAgICAgICAgICAgICAgIDogJ251bGwnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vSWYgbm9kZSBpcyBhZGRlZCBhcyBwYXJlbnQsIHRoZW4gbGFzdCBjaGlsZCBpcyBzZXQgdG8gbnVsbFxyXG4gICAgICAvL2FuZCBwYXJlbnQgaGlzdG9yeSBpcyBjbGVhcmVkLlxyXG4gICAgICBfbGFzdENoaWxkID0gbnVsbDtcclxuICAgICAgX3BhcmVudEhpc3RvcnkubGVuZ3RoID0gMDtcclxuICAgICAgLy9BZnRlciB0aGF0LCBuZXcgbm9kZSBpcyBjcmVhdGVkLlxyXG4gICAgICBsZXQgbm9kZSA9IF9ub2RlRmFjdG9yeShwYXJhbXMsX3NlbGYpO1xyXG4gICAgICBfcGFyZW50SGlzdG9yeSA9IFtub2RlXTtcclxuICAgICAgX2FkZE5vZGUoc3RvcmFnZSxub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0V2FpdGluZ1dpcmVzRm9yTm9kZShpZCkubWFwKCh3aXJlKSA9PiB7XHJcbiAgICAgIC8vY29uc29sZS5sb2coJ3dpcmUnLHdpcmUsd2lyZS50eXBlLHdpcmUudGFyZ2V0Tm9kZSx3aXJlLnJlZmVyZW5jZU5vZGUpO1xyXG4gICAgICBfc2V0Q29ubmVjdGlvbih3aXJlLnR5cGUsd2lyZS50YXJnZXROb2RlLHdpcmUucmVmZXJlbmNlTm9kZSk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGROb2RlKG5vZGVQYXJhbXMpIHtcclxuICAgICAgLy9XZSBjcmVhdGUgYSBuZXcgbm9kZSwgYW5kIHRoZW4gc2V0IGFzIHRoZSBsYXN0IGNoaWxkLlxyXG4gICAgICBfbGFzdENoaWxkID0gX25vZGVGYWN0b3J5KG5vZGVQYXJhbXMsX3NlbGYpO1xyXG4gICAgICAvL1RoZW4gd2UgYWRkIG91ciBmcmVzaGx5IGNyZWF0ZWQgbm9kZSB0byBpdHMgcGFyZW50LlxyXG4gICAgICBfcGFyZW50SGlzdG9yeVswXS5hZGRDaGlsZChfbGFzdENoaWxkLmdldElkKCkpO1xyXG4gICAgICAvL0ZpbmFsbHkgbmV3IG5vZGUgaXMgYWRkZWQgdG8gbWFpbiBzdG9yYWdlIG9iamVjdC5cclxuICAgICAgX2FkZE5vZGUoc3RvcmFnZSxfbGFzdENoaWxkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9nZXRXYWl0aW5nV2lyZXNGb3JOb2RlKG5vZGVJZCkge1xyXG4gICAgbGV0IHdpcmVzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gX3RlbXBXaXJlcy5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcclxuICAgICAgLy9jb25zb2xlLmxvZygnX2dldFdhaXRpbmdXaXJlc0Zvck5vZGUnLF90ZW1wV2lyZXNbaV0ucmVmZXJlbmNlTm9kZSxub2RlSWQpO1xyXG4gICAgICBpZihfdGVtcFdpcmVzW2ldLnJlZmVyZW5jZU5vZGUgPT09IG5vZGVJZCkge1xyXG4gICAgICAgIHdpcmVzLnB1c2goX3RlbXBXaXJlcy5zcGxpY2UoaSwxKVswXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB3aXJlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIHJlbW92ZSBub2RlcyBmcm9tIG9iamVjdCBwb29sXHJcbiAgICogYW5kIHJlc2V0IGNvbnRleHQgb2YgXCJtZXRob2QgY2hhaW5pbmdcIiBhbGdvcml0aG0uXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgSWQgb2Ygbm9kZSB0byBiZSByZW1vdmVkLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IE5hbWUgb2Ygbm9kZSBncm91cCB3aGljaCBjb250YWlucyBub2RlIHRvIHJlbW92ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfY2hhaW5Ob2RlUmVtb3ZlcihpZCxrZXkpIHtcclxuICAgIF9sYXN0Q2hpbGQgPSBudWxsO1xyXG4gICAgX3BhcmVudEhpc3RvcnkubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX3JlbW92ZU5vZGVCeUtleShrZXksaWQpO1xyXG4gIH1cclxuXHJcbiAgbGV0IF9hZGRBY3RvciA9IGZ1bmN0aW9uKGlkLHBhcmFtcykge1xyXG4gICAgX2NoYWluTm9kZUNyZWF0b3IoaWQscGFyYW1zLGZhbHNlLCdBY3Rvck5vZGUnLEtFWV9BQ1RPUlMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3JlbW92ZUFjdG9yID0gZnVuY3Rpb24oYWN0b3JJZCkge1xyXG4gICAgX2NoYWluTm9kZVJlbW92ZXIoYWN0b3JJZCxLRVlfQUNUT1JTKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIF9hZGRRdWVzdCA9IGZ1bmN0aW9uKGlkLHBhcmFtcykge1xyXG4gICAgX2NoYWluTm9kZUNyZWF0b3IoaWQscGFyYW1zLGZhbHNlLCdRdWVzdE5vZGUnLEtFWV9RVUVTVFMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3JlbW92ZVF1ZXN0ID0gZnVuY3Rpb24ocXVlc3RJZCkge1xyXG4gICAgX2NoYWluTm9kZVJlbW92ZXIocXVlc3RJZCxLRVlfUVVFU1RTKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIF9hZGREaWFsb2cgPSBmdW5jdGlvbihpZCxwYXJhbXMpIHtcclxuICAgIF9jaGFpbk5vZGVDcmVhdG9yKGlkLHBhcmFtcyxmYWxzZSwnRGlhbG9nTm9kZScsS0VZX0RJQUxPR1MpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3JlbW92ZURpYWxvZyA9IGZ1bmN0aW9uKGRpYWxvZ0lkKSB7XHJcbiAgICBfY2hhaW5Ob2RlUmVtb3ZlcihkaWFsb2dJZCxLRVlfRElBTE9HUyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBfYWRkQ29uZGl0aW9uID0gZnVuY3Rpb24oaWQscGFyYW1zKSB7XHJcbiAgICBfY2hhaW5Ob2RlQ3JlYXRvcihpZCxwYXJhbXMsZmFsc2UsJ1NjcmlwdE5vZGUnLEtFWV9MT0dJQyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBfcmVtb3ZlQ29uZGl0aW9uID0gZnVuY3Rpb24oY29uZGl0aW9uSWQpIHtcclxuICAgIF9jaGFpbk5vZGVSZW1vdmVyKGNvbmRpdGlvbklkLEtFWV9MT0dJQyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBfYWRkVmFyaWFibGUgPSBmdW5jdGlvbihpZCxwYXJhbXMpIHtcclxuICAgIF9jaGFpbk5vZGVDcmVhdG9yKGlkLHBhcmFtcyxmYWxzZSwnVmFyaWFibGVOb2RlJyxLRVlfVkFSSUFCTEVTKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIF9yZW1vdmVWYXJpYWJsZSA9IGZ1bmN0aW9uKHZhcmlhYmxlSWQpIHtcclxuICAgIF9jaGFpbk5vZGVSZW1vdmVyKHZhcmlhYmxlSWQsS0VZX1ZBUklBQkxFUyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBfYWRkVGFsayA9IGZ1bmN0aW9uKGlkLHBhcmFtcykge1xyXG4gICAgX2NoYWluTm9kZUNyZWF0b3IoaWQscGFyYW1zLHRydWUsJ1RhbGtOb2RlJyxLRVlfVEFMS1MpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3JlbW92ZVRhbGsgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgX2NoYWluTm9kZVJlbW92ZXIoaWQsS0VZX1RBTEtTKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIF9hZGRBbnN3ZXIgPSBmdW5jdGlvbihpZCxwYXJhbXMpIHtcclxuICAgIF9jaGFpbk5vZGVDcmVhdG9yKGlkLHBhcmFtcyx0cnVlLCdBbnN3ZXJOb2RlJyxLRVlfQU5TV0VSUyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBfcmVtb3ZlQW5zd2VyID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIF9jaGFpbk5vZGVSZW1vdmVyKGlkLEtFWV9BTlNXRVJTKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIF9zZXRXaXJlID0gZnVuY3Rpb24odHlwZSxyZWZlcmVuY2VOb2RlSWQpIHtcclxuICAgIGxldCB0YXJnZXROb2RlID0gX2xhc3RDaGlsZDtcclxuICAgIGlmKHRhcmdldE5vZGUgPT09IG51bGwgJiYgX3BhcmVudEhpc3RvcnkubGVuZ3RoID4gMCkge1xyXG4gICAgICB0YXJnZXROb2RlID0gX3BhcmVudEhpc3RvcnlbMF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLypfZXJyb3JIYW5kbGVyLnNob3dNc2coRXJyb3JDb2RlLklOQ09NUEFUSUJMRV9DSElMRCx7XHJcbiAgICAgICAgY2hpbGQ6Y2xhc3NOYW1lLFxyXG4gICAgICAgIHBhcmVudDogX3BhcmVudEhpc3RvcnkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgID8gX3BhcmVudEhpc3RvcnlbMF0uY29uc3RydWN0b3IubmFtZVxyXG4gICAgICAgICAgICAgIDogJ251bGwnXHJcbiAgICAgIH0pOyovXHJcbiAgICB9XHJcbiAgICBfc2V0Q29ubmVjdGlvbih0eXBlLHRhcmdldE5vZGUuZ2V0SWQoKSxyZWZlcmVuY2VOb2RlSWQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vR0VUVEVSU1xyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICBfZ2V0QWN0b3IgPSBmdW5jdGlvbihhY3RvcklkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZE5vZGUoYWN0b3JJZCk7XHJcbiAgfSxcclxuXHJcbiAgX2dldEFjdG9ycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIF9vYmplY3RQb29sW0tFWV9BQ1RPUlNdO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRDb25kaXRpb24gPSBmdW5jdGlvbihjb25kaXRpb25JZCkge1xyXG4gICAgcmV0dXJuIF9maW5kTm9kZShjb25kaXRpb25JZCk7XHJcbiAgfSxcclxuXHJcbiAgX2dldENvbmRpdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfb2JqZWN0UG9vbFtLRVlfTE9HSUNdO1xyXG4gIH0sXHJcblxyXG4gIF9nZXREaWFsb2cgPSBmdW5jdGlvbihkaWFsb2dJZCkge1xyXG4gICAgcmV0dXJuIF9maW5kTm9kZShkaWFsb2dJZCk7XHJcbiAgfSxcclxuXHJcbiAgX2dldERpYWxvZ3MgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfb2JqZWN0UG9vbFtLRVlfRElBTE9HU107XHJcbiAgfSxcclxuXHJcbiAgX2dldFF1ZXN0ID0gZnVuY3Rpb24ocXVlc3RJZCkge1xyXG4gICAgcmV0dXJuIF9maW5kTm9kZShxdWVzdElkKTtcclxuICB9LFxyXG5cclxuICBfZ2V0UXVlc3RzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gX29iamVjdFBvb2xbS0VZX1FVRVNUU107XHJcbiAgfSxcclxuXHJcbiAgX2dldFZhcmlhYmxlID0gZnVuY3Rpb24odmFyaWFibGVJZCkge1xyXG4gICAgcmV0dXJuIF9maW5kTm9kZSh2YXJpYWJsZUlkKTtcclxuICB9LFxyXG5cclxuICBfZ2V0VmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gX29iamVjdFBvb2xbS0VZX1ZBUklBQkxFU107XHJcbiAgfSxcclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vTUlTQ0FMSU5FVVNcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gIF9zZXRWYXIgPSBmdW5jdGlvbih2YXJpYWJsZUlkLHZhbHVlKSB7XHJcbiAgICBsZXQgX3ZhciA9IF9nZXRWYXJpYWJsZSh2YXJpYWJsZUlkKTtcclxuICAgIGlmKF92YXIgIT09IG51bGwpIF92YXIuc2V0VmFsdWUodmFsdWUpO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRWYXIgPSBmdW5jdGlvbih2YXJpYWJsZUlkKSB7XHJcbiAgICBsZXQgX3ZhciA9IF9nZXRWYXJpYWJsZSh2YXJpYWJsZUlkKTtcclxuICAgIHJldHVybiBfdmFyICE9PSBudWxsID8gX3Zhci5nZXRWYWx1ZSgpIDogdW5kZWZpbmVkO1xyXG4gIH0sXHJcblxyXG4gIF9zZXJpYWxpemVEYXRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICBsZXQgZGF0YSA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIF9vYmplY3RQb29sKSB7XHJcbiAgICAgIGlmIChfb2JqZWN0UG9vbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgZGF0YVtrZXldID0gX29iamVjdFBvb2xba2V5XS5tYXAoKG9iaikgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIG9iai5nZXREYXRhID8gb2JqLmdldERhdGEoKSA6IG9iajtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gIH07XHJcblxyXG4gIGxldCBfc2VsZiA9IHtcclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvL0dlbmVyYWwgbm9kZSBtZXRob2RzXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgZmluZE5vZGU6ICAgICAgICAgX2ZpbmROb2RlLFxyXG4gICAgLy9nZXROb2RlOiAgICAgICAgICBfZ2V0Tm9kZSxcclxuICAgIGFkZE5vZGU6ICAgICAgICAgIF9hZGROb2RlLFxyXG4gICAgcmVtb3ZlTm9kZTogICAgICAgX3JlbW92ZU5vZGUsXHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vTGluayBjcmVhdGlvbiBtZXRob2RzXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgc2V0V2lyZTogICAgICAgICBfc2V0V2lyZSxcclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy9DaGFpbmFibGUgbWV0aG9kc1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIGFkZEFjdG9yOiAgICAgICAgX2FkZEFjdG9yLFxyXG4gICAgcmVtb3ZlQWN0b3I6ICAgICBfcmVtb3ZlQWN0b3IsXHJcbiAgICBhZGRRdWVzdDogICAgICAgIF9hZGRRdWVzdCxcclxuICAgIHJlbW92ZVF1ZXN0OiAgICAgX3JlbW92ZVF1ZXN0LFxyXG4gICAgYWRkRGlhbG9nOiAgICAgICBfYWRkRGlhbG9nLFxyXG4gICAgcmVtb3ZlRGlhbG9nOiAgICBfcmVtb3ZlRGlhbG9nLFxyXG4gICAgYWRkQ29uZGl0aW9uOiAgICBfYWRkQ29uZGl0aW9uLFxyXG4gICAgcmVtb3ZlQ29uZGl0aW9uOiBfcmVtb3ZlQ29uZGl0aW9uLFxyXG4gICAgYWRkVmFyaWFibGU6ICAgICBfYWRkVmFyaWFibGUsXHJcbiAgICByZW1vdmVWYXJpYWJsZTogIF9yZW1vdmVWYXJpYWJsZSxcclxuICAgIGFkZFRhbGs6ICAgICAgICAgX2FkZFRhbGssXHJcbiAgICByZW1vdmVUYWxrOiAgICAgIF9yZW1vdmVUYWxrLFxyXG4gICAgYWRkQW5zd2VyOiAgICAgICBfYWRkQW5zd2VyLFxyXG4gICAgcmVtb3ZlQW5zd2VyOiAgICBfcmVtb3ZlQW5zd2VyLFxyXG4gICAgLy9pbnA6ICAgICAgICAgICAgIF9pbnAsXHJcbiAgICAvL291dDogICAgICAgICAgICAgX291dCxcclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy9HZXR0ZXIgbWV0aG9kc1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIGdldEFjdG9yOiAgICAgICAgX2dldEFjdG9yLFxyXG4gICAgZ2V0QWN0b3JzOiAgICAgICBfZ2V0QWN0b3JzLFxyXG4gICAgZ2V0Q29uZGl0aW9uOiAgICBfZ2V0Q29uZGl0aW9uLFxyXG4gICAgZ2V0Q29uZGl0aW9uczogICBfZ2V0Q29uZGl0aW9ucyxcclxuICAgIGdldERpYWxvZzogICAgICAgX2dldERpYWxvZyxcclxuICAgIGdldERpYWxvZ3M6ICAgICAgX2dldERpYWxvZ3MsXHJcbiAgICBnZXRRdWVzdDogICAgICAgIF9nZXRRdWVzdCxcclxuICAgIGdldFF1ZXN0czogICAgICAgX2dldFF1ZXN0cyxcclxuICAgIGdldFZhcmlhYmxlOiAgICAgX2dldFZhcmlhYmxlLFxyXG4gICAgZ2V0VmFyaWFibGVzOiAgICBfZ2V0VmFyaWFibGVzLFxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvL01pc2NhbGluZXVzIG1ldGhvZHNcclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICBzZXRWYXI6ICAgICAgICAgICBfc2V0VmFyLFxyXG4gICAgZ2V0VmFyOiAgICAgICAgICAgX2dldFZhcixcclxuICAgIHNlcmlhbGl6ZURhdGE6ICAgIF9zZXJpYWxpemVEYXRhXHJcbiAgfTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgX29iamVjdFBvb2xba2V5XSA9IGRhdGFba2V5XS5tYXAoKGQpID0+IF9ub2RlRmFjdG9yeShkLF9zZWxmKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gX3NlbGY7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gUlBHU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IEJhc2VOb2RlIGZyb20gJy4uL2NvcmUvQmFzZU5vZGUnO1xyXG5pbXBvcnQgUHJvcCAgIGZyb20gJy4uL2NvcmUvUHJvcCc7XHJcblxyXG5sZXQgQWN0b3JOb2RlID0gKGZ1bmN0aW9uKCkge1xyXG4gIC8vV2VhayBtYXBzIGFyZSBuZXcgZmVhdHVyZSB0byBKYXZhU2NyaXB0LiBXZSBjYW4gc3RvcmUgcHJpdmF0ZVxyXG4gIC8vb2JqZWN0IHByb3BlcnRpZXMgaW4ga2V5L3ZhbHVlIHBhaXJzIHVzaW5nIG91ciBpbnN0YW5jZSBhcyB0aGUga2V5LFxyXG4gIC8vYW5kIG91ciBjbGFzcyBjYW4gY2FwdHVyZSB0aG9zZSBrZXkvdmFsdWUgbWFwcyBpbiBhIGNsb3N1cmUuXHJcbiAgbGV0IF9uYW1lID0gbmV3IFdlYWtNYXAoKTtcclxuICBsZXQgX2RpYWxvZyA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgLy9sZXQgX2ludmVudG9yeSA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cclxuICByZXR1cm4gY2xhc3MgQWN0b3JOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgICBzdXBlcihkYXRhKTtcclxuICAgICAgX25hbWUuc2V0KHRoaXMsZGF0YSA/IGRhdGEubmFtZSA6ICcnKTtcclxuICAgICAgX2RpYWxvZy5zZXQodGhpcyxkYXRhID8gZGF0YS5kaWFsb2cgOiAnJyk7XHJcbiAgICAgIC8vX2ludmVudG9yeS5zZXQodGhpcyxkYXRhLmludmVudG9yeSA/ICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF0YSgpIHtcclxuICAgICAgbGV0IGRhdGEgPSBzdXBlci5nZXREYXRhKCk7XHJcbiAgICAgIGRhdGEubmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xyXG4gICAgICBkYXRhLmRpYWxvZyA9IHRoaXMuZ2V0RGlhbG9nKCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHNldE5hbWUodmFsdWUpIHtcclxuICAgICAgX25hbWUuc2V0KHRoaXMsdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5hbWUoKSB7XHJcbiAgICAgIHJldHVybiBfbmFtZS5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGlhbG9nKCkge1xyXG4gICAgICByZXR1cm4gX2RpYWxvZy5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLypnZXRJbnZlbnRvcnkoKSB7XHJcbiAgICAgIHJldHVybiBfaW52ZW50b3J5LmdldCh0aGlzKTtcclxuICAgIH0qL1xyXG5cclxuICAgIGNhblNldFdpcmVUeXBlKHR5cGUpIHtcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBQcm9wLkRJQUxPRzpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVzKFByb3AuRElBTE9HKS5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgX25hbWUuZGVsZXRlKHRoaXMpO1xyXG4gICAgICBfZGlhbG9nLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgLy9faW52ZW50b3J5LmRlbGV0ZSh0aGlzKTtcclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICB9XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFjdG9yTm9kZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCB7VVVJRH0gICBmcm9tICcuL1V0aWxzJztcclxuaW1wb3J0IFByb3AgZnJvbSAnLi9Qcm9wJztcclxuXHJcbmxldCBCYXNlTm9kZSA9IChmdW5jdGlvbigpe1xyXG4gIC8vV2VhayBtYXBzIGFyZSBuZXcgZmVhdHVyZSB0byBKYXZhU2NyaXB0LiBXZSBjYW4gc3RvcmUgcHJpdmF0ZVxyXG4gIC8vb2JqZWN0IHByb3BlcnRpZXMgaW4ga2V5L3ZhbHVlIHBhaXJzIHVzaW5nIG91ciBpbnN0YW5jZSBhcyB0aGUga2V5LFxyXG4gIC8vYW5kIG91ciBjbGFzcyBjYW4gY2FwdHVyZSB0aG9zZSBrZXkvdmFsdWUgbWFwcyBpbiBhIGNsb3N1cmUuXHJcbiAgbGV0IF9ycGdzID0gbmV3IFdlYWtNYXAoKTtcclxuICBsZXQgX3V1aWQgPSBuZXcgV2Vha01hcCgpO1xyXG4gIGxldCBfd2lyZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICByZXR1cm4gY2xhc3MgQmFzZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSxycGdzKSB7XHJcbiAgICAgIF9ycGdzLnNldCh0aGlzLHJwZ3MpO1xyXG4gICAgICAvL0lmIHV1aWQgbm90IHByZXNlbnQsIHRoZW4gYnkgZGVmYXVsdCB3ZSBhc3NpZ24gVW5pdmVyc2FsbHkgVW5pcXVlIElELlxyXG4gICAgICBfdXVpZC5zZXQodGhpcyxkYXRhLnV1aWQgPyBkYXRhLnV1aWQgOiBVVUlELmdlbmVyYXRlKCkpO1xyXG4gICAgICBfd2lyZXMuc2V0KHRoaXMsZGF0YS53aXJlcyA/IGRhdGEud2lyZXMgOiB7fSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UlBHUygpIHtcclxuICAgICAgcmV0dXJuIF9ycGdzLmdldCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJZCh2YWx1ZSkge1xyXG4gICAgICBfdXVpZC5zZXQodGhpcyx2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SWQoKSB7XHJcbiAgICAgIHJldHVybiBfdXVpZC5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoZWNrQ29uZGl0aW9uKHByb3ApIHtcclxuICAgICAgbGV0IG5vZGVJZCA9IHRoaXMuZ2V0V2lyZXMocHJvcClbMF07XHJcbiAgICAgIGxldCBzY3JpcHROb2RlID0gdGhpcy5nZXRSUEdTKCkuZmluZE5vZGUobm9kZUlkKTtcclxuICAgICAgcmV0dXJuIHNjcmlwdE5vZGUgIT0gbnVsbCAmJiBzY3JpcHROb2RlLmV4ZWN1dGUgPyBzY3JpcHROb2RlLmV4ZWN1dGUoKSA6IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGJvb2xlYW4gdGhhdCByZWZsZWN0cyB2aXNpYmxpbGl0eSBzdGF0ZSBvZiBub2RlLlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVmlzaWJpbGl0eSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBpc1Zpc2libGUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jaGVja0NvbmRpdGlvbihQcm9wLlZJU0lCSUxJVFkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib29sZWFuIHRoYXQgcmVmbGVjdHMgYWN0aXZpdHkgc3RhdGUgb2Ygbm9kZS5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IEFjdGl2ZSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBpc0FjdGl2ZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrQ29uZGl0aW9uKFByb3AuQUNUSVZJVFkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGEoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3M6dGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxyXG4gICAgICAgIHV1aWQ6dGhpcy5nZXRJZCgpLFxyXG4gICAgICAgIHdpcmVzOl93aXJlcy5nZXQodGhpcylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjYW5BZGRDaGlsZCh0eXBlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDaGlsZChjaGlsZElkKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUNoaWxkKGluZGV4KSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldENoaWxkKGluZGV4KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENoaWxkcmVuKCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbW92ZUNoaWxkcmVuKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjYW5TZXRXaXJlVHlwZSh0eXBlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0V2lyZShvYmosdHlwZSxub2RlSWQpIHtcclxuICAgICAgaWYoIW9iai5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xyXG4gICAgICAgIG9ialt0eXBlXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIG9ialt0eXBlXS5wdXNoKG5vZGVJZCk7XHJcbiAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0V2lyZSh0eXBlLG5vZGVJZCkge1xyXG4gICAgICBfd2lyZXMuc2V0KHRoaXMsdGhpcy5fc2V0V2lyZShfd2lyZXMuZ2V0KHRoaXMpLHR5cGUsbm9kZUlkKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldFdpcmVzKG9iaix0eXBlKSB7XHJcbiAgICAgIC8vY29uc29sZS5sb2coJ19nZXRXaXJlcycsb2JqKTtcclxuICAgICAgaWYodHlwZSkgcmV0dXJuICFvYmouaGFzT3duUHJvcGVydHkodHlwZSkgPyBbXSA6IG9ialt0eXBlXTtcclxuICAgICAgZWxzZSByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFdpcmVzKHR5cGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldFdpcmVzKF93aXJlcy5nZXQodGhpcyksdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlbW92ZVdpcmUob2JqLHR5cGUsbm9kZUlkKSB7XHJcbiAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xyXG4gICAgICAgIG9ialt0eXBlXSA9IFV0aWxzLnJlbW92ZU9iamVjdEZyb21BcnJheShvYmpbdHlwZV0sbm9kZUlkKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZVdpcmUodHlwZSxub2RlSWQpIHtcclxuICAgICAgX3dpcmVzLnNldCh0aGlzLHRoaXMuX3JlbW92ZVdpcmUoX3dpcmVzLmdldCh0aGlzKSx0eXBlLG5vZGVJZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIF9ycGdzLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgX3V1aWQuZGVsZXRlKHRoaXMpO1xyXG4gICAgICBfd2lyZXMuZGVsZXRlKHRoaXMpO1xyXG4gICAgICBfcmVtb3ZlQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VOb2RlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IEJhc2VOb2RlIGZyb20gJy4uL2NvcmUvQmFzZU5vZGUnO1xyXG5pbXBvcnQgVXRpbHMgICAgZnJvbSAnLi4vY29yZS9VdGlscyc7XHJcblxyXG5sZXQgQ29tcG91bmROb2RlID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBfY2hpbGRyZW4gPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICByZXR1cm4gY2xhc3MgQ29tcG91bmROb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRhdGEscnBncykge1xyXG4gICAgICBzdXBlcihkYXRhLHJwZ3MpO1xyXG4gICAgICBfY2hpbGRyZW4uc2V0KHRoaXMsZGF0YS5jaGlsZHJlbiA/IGRhdGEuY2hpbGRyZW4gOiBbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF0YSgpIHtcclxuICAgICAgbGV0IGRhdGEgPSBzdXBlci5nZXREYXRhKCk7XHJcbiAgICAgIGRhdGEuY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZENoaWxkKGNoaWxkSWQpIHtcclxuICAgICAgbGV0IGNoaWxkcmVuID0gX2NoaWxkcmVuLmdldCh0aGlzKTtcclxuICAgICAgX2NoaWxkcmVuLnNldCh0aGlzLFV0aWxzLmFkZE9iamVjdFRvQXJyYXkoY2hpbGRyZW4sY2hpbGRJZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUNoaWxkKGluZGV4KSB7XHJcbiAgICAgIGxldCBjaGlsZHJlbiA9IF9jaGlsZHJlbi5nZXQodGhpcyk7XHJcbiAgICAgIF9jaGlsZHJlbi5zZXQodGhpcyxjaGlsZHJlbi5zcGxpY2UoaW5kZXgsMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENoaWxkKGluZGV4KSB7XHJcbiAgICAgIGxldCBjaGlsZHJlbiA9IF9jaGlsZHJlbi5nZXQodGhpcyk7XHJcbiAgICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPiBpbmRleCA/IGNoaWxkcmVuW2luZGV4XSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2hpbGRyZW4oKSB7XHJcbiAgICAgIHJldHVybiBfY2hpbGRyZW4uZ2V0KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZW1vdmVDaGlsZHJlbigvKmtleSovKSB7XHJcbiAgICAgIC8vQWRkIHZhbGlkIGltcGxlbWVudGF0aW9uLi4uXHJcbiAgICAgIC8vdGhpcy5yZW1vdmVDaGlsZHJlbkZyb20oX2NoaWxkcmVuLmdldCh0aGlzKSxrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIF9jaGlsZHJlbi5kZWxldGUodGhpcyk7XHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG59KSgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvdW5kTm9kZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBOT0RFX05PVF9FWElTVFMgPSAwO1xyXG5jb25zdCBDTEFTU19OT1RfREVGSU5FRCA9IDE7XHJcbmNvbnN0IENPTk5FQ1RJT05fVE9fSVRTRUxGID0gMjtcclxuY29uc3QgSU1QUk9QRVJfQ09OTkVDVElPTiA9IDM7XHJcbmNvbnN0IE9CSkVDVF9OT1RfRk9VTkQgPSA0O1xyXG5jb25zdCBNQU5EQVRPUllfUEFSQU0gPSA1O1xyXG5jb25zdCBJTkNPUlJFQ1RfVFlQRSA9IDY7XHJcbmNvbnN0IElOQ09SUkVDVF9QQVJFTlRfTk9ERSA9IDc7XHJcbmNvbnN0IElOQ09SUkVDVF9MSU5LX1RBUkdFVCA9IDg7XHJcbmNvbnN0IElOQ09NUEFUSUJMRV9DSElMRCA9IDk7XHJcblxyXG5leHBvcnRzLk5PREVfTk9UX0VYSVNUUyA9IE5PREVfTk9UX0VYSVNUUztcclxuZXhwb3J0cy5DTEFTU19OT1RfREVGSU5FRCA9IENMQVNTX05PVF9ERUZJTkVEO1xyXG5leHBvcnRzLkNPTk5FQ1RJT05fVE9fSVRTRUxGID0gQ09OTkVDVElPTl9UT19JVFNFTEY7XHJcbmV4cG9ydHMuSU1QUk9QRVJfQ09OTkVDVElPTiA9IElNUFJPUEVSX0NPTk5FQ1RJT047XHJcbmV4cG9ydHMuT0JKRUNUX05PVF9GT1VORCA9IE9CSkVDVF9OT1RfRk9VTkQ7XHJcbmV4cG9ydHMuTUFOREFUT1JZX1BBUkFNID0gTUFOREFUT1JZX1BBUkFNO1xyXG5leHBvcnRzLklOQ09SUkVDVF9UWVBFID0gSU5DT1JSRUNUX1RZUEU7XHJcbmV4cG9ydHMuSU5DT1JSRUNUX1BBUkVOVF9OT0RFID0gSU5DT1JSRUNUX1BBUkVOVF9OT0RFO1xyXG5leHBvcnRzLklOQ09SUkVDVF9MSU5LX1RBUkdFVCA9IElOQ09SUkVDVF9MSU5LX1RBUkdFVDtcclxuZXhwb3J0cy5JTkNPTVBBVElCTEVfQ0hJTEQgPSBJTkNPTVBBVElCTEVfQ0hJTEQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IEVycm9yQ29kZSBmcm9tICcuL0Vycm9yQ29kZSc7XHJcblxyXG5cclxubGV0IEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVkaXRvcil7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNob3dNc2c6ZnVuY3Rpb24oZXJyb3JDb2RlLHBhcmFtcykge1xyXG4gICAgICBsZXQgbXNnID0gJyc7XHJcbiAgICAgIHN3aXRjaCAoZXJyb3JDb2RlKSB7XHJcbiAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9ERV9OT1RfRVhJU1RTOlxyXG4gICAgICAgICAgbXNnID0gYE5vZGUgb2YgdHlwZSAke3BhcmFtcy50eXBlfSBpcyBub3QgZGVmaW5lZC5gO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFcnJvckNvZGUuQ0xBU1NfTk9UX0RFRklORUQ6XHJcbiAgICAgICAgICBtc2cgPSBgQ2xhc3MgJHtwYXJhbXMuY2xhc3N9IGlzIG5vdCBkZWZpbmVkLmA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVycm9yQ29kZS5DT05ORUNUSU9OX1RPX0lUU0VMRjpcclxuICAgICAgICAgIG1zZyA9IGBDYW5ub3QgY29ubmVjdCBub2RlIFwiJHtwYXJhbXMubm9kZX1cIiB0byBpdHNlbGYuYDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXJyb3JDb2RlLklNUFJPUEVSX0NPTk5FQ1RJT046XHJcbiAgICAgICAgICBtc2cgPSBgQ2Fubm90IGNyZWF0ZSBjb25uZWN0aW9uIG9mIHR5cGUgXCIke3BhcmFtcy50eXBlfVwiIGZyb20gbm9kZSBpZCBcIiR7cGFyYW1zLm5vZGUxfVwiIHRvIG5vZGUgaWQgXCIke3BhcmFtcy5ub2RlMn1cIi5gO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFcnJvckNvZGUuT0JKRUNUX05PVF9GT1VORDpcclxuICAgICAgICAgIG1zZyA9IGBDYW5ub3QgZmluZCBvYmplY3Qgd2l0aCBpZCBcIiR7cGFyYW1zLmlkfVwiYDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXJyb3JDb2RlLk1BTkRBVE9SWV9QQVJBTTpcclxuICAgICAgICAgIG1zZyA9IGBQYXJhbWV0ZXIgXCIke3BhcmFtcy5wYXJhbX1cIiB3YXMgZXhwZWN0ZWQgYnV0IGluc3RlYWQgZ290IHVuZGVmaW5lZC5gO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFcnJvckNvZGUuSU5DT1JSRUNUX1RZUEU6XHJcbiAgICAgICAgICBtc2cgPSBgV3JvbmcgdHlwZSBvZiBhcmd1bWVudC4gRXhwZWN0ZWQgXCIke3BhcmFtcy50eXBlfVwiYDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRXJyb3JDb2RlLklOQ09SUkVDVF9QQVJFTlRfTk9ERTpcclxuICAgICAgICAgIG1zZyA9IGBOb2RlIG9mIHR5cGUgXCIke3BhcmFtcy5jaGlsZH1cIiBjYW4gYmUgYWRkZWQgb25seSB0byBcIiR7cGFyYW1zLnBhcmVudH1cIiBub2RlLmA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVycm9yQ29kZS5JTkNPUlJFQ1RfTElOS19UQVJHRVQ6XHJcbiAgICAgICAgICBtc2cgPSBgQ2Fubm90IGNyZWF0ZSBsaW5rIGNvbm5lY3Rpb24gdG8gbnVsbCBub2RlLmA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVycm9yQ29kZS5JTkNPTVBBVElCTEVfQ0hJTEQ6XHJcbiAgICAgICAgICBtc2cgPSBgQ2Fubm90IGFkZCBjaGlsZCBvZiB0eXBlIFwiJHtwYXJhbXMuY2hpbGR9XCIgaW50byBwYXJlbnQgb2YgdHlwZSBcIiR7cGFyYW1zLnBhcmVudH1cIi5gO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIG1zZyA9IGBVbmtub3duIGVycm9yIGNvZGUgcGFzc2VkOiAke2Vycm9yQ29kZX1gO1xyXG4gICAgICB9XHJcbiAgICAgIGlmKGVkaXRvcikge1xyXG4gICAgICAgIGVkaXRvci5zaG93TXNnKG1zZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgICAgLy9hZGQgd2FybmluZyBtb2RlP1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBFcnJvckhhbmRsZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgUkVGRVJFTkNFID0gJ3JlZmVyZW5jZSc7XHJcbmNvbnN0IFZJU0lCSUxJVFkgPSAndmlzaWJpbGl0eSc7XHJcbmNvbnN0IEFDVElWSVRZID0gJ2FjdGl2aXR5JztcclxuY29uc3QgQUNUSU9OID0gJ2FjdGlvbic7XHJcbmNvbnN0IEdPVE8gPSAnZ290byc7XHJcbmNvbnN0IERJQUxPRyA9ICdkaWFsb2cnO1xyXG5cclxuZXhwb3J0cy5SRUZFUkVOQ0UgPSBSRUZFUkVOQ0U7XHJcbmV4cG9ydHMuVklTSUJJTElUWSA9IFZJU0lCSUxJVFk7XHJcbmV4cG9ydHMuQUNUSVZJVFkgPSBBQ1RJVklUWTtcclxuZXhwb3J0cy5BQ1RJT04gPSBBQ1RJT047XHJcbmV4cG9ydHMuR09UTyA9IEdPVE87XHJcbmV4cG9ydHMuRElBTE9HID0gRElBTE9HO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBGYXN0IFVVSUQgZ2VuZXJhdG9yLCBSRkM0MTIyIHZlcnNpb24gNCBjb21wbGlhbnQuXHJcbiAqIEBhdXRob3IgSmVmZiBXYXJkIChqY3dhcmQuY29tKS5cclxuICogQGxpY2Vuc2UgTUlUIGxpY2Vuc2VcclxuICogQGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XHJcbiAqKi9cclxudmFyIFVVSUQgPSAoZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHNlbGYgPSB7fTtcclxuICB2YXIgbHV0ID0gW107IGZvciAodmFyIGk9MDsgaTwyNTY7IGkrKykgeyBsdXRbaV0gPSAoaTwxNj8nMCc6JycpKyhpKS50b1N0cmluZygxNik7IH1cclxuICBzZWxmLmdlbmVyYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZDAgPSBNYXRoLnJhbmRvbSgpKjB4ZmZmZmZmZmZ8MDtcclxuICAgIHZhciBkMSA9IE1hdGgucmFuZG9tKCkqMHhmZmZmZmZmZnwwO1xyXG4gICAgdmFyIGQyID0gTWF0aC5yYW5kb20oKSoweGZmZmZmZmZmfDA7XHJcbiAgICB2YXIgZDMgPSBNYXRoLnJhbmRvbSgpKjB4ZmZmZmZmZmZ8MDtcclxuICAgIHJldHVybiBsdXRbZDAmMHhmZl0rbHV0W2QwPj44JjB4ZmZdK2x1dFtkMD4+MTYmMHhmZl0rbHV0W2QwPj4yNCYweGZmXSsnLScrXHJcbiAgICAgIGx1dFtkMSYweGZmXStsdXRbZDE+PjgmMHhmZl0rJy0nK2x1dFtkMT4+MTYmMHgwZnwweDQwXStsdXRbZDE+PjI0JjB4ZmZdKyctJytcclxuICAgICAgbHV0W2QyJjB4M2Z8MHg4MF0rbHV0W2QyPj44JjB4ZmZdKyctJytsdXRbZDI+PjE2JjB4ZmZdK2x1dFtkMj4+MjQmMHhmZl0rXHJcbiAgICAgIGx1dFtkMyYweGZmXStsdXRbZDM+PjgmMHhmZl0rbHV0W2QzPj4xNiYweGZmXStsdXRbZDM+PjI0JjB4ZmZdO1xyXG4gIH1cclxuICByZXR1cm4gc2VsZjtcclxufSkoKTtcclxuXHJcbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XHJcblxyXG5sZXQgaW5kZXhPZk9iamVjdCA9IGZ1bmN0aW9uKGFycmF5LG9iaikge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmKGFycmF5W2ldID09PSBvYmopIHJldHVybiBpO1xyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn07XHJcblxyXG5leHBvcnRzLmluZGV4T2ZPYmplY3QgPSBpbmRleE9mT2JqZWN0O1xyXG5cclxubGV0IGdldEluZGV4QnlJZCA9IGZ1bmN0aW9uKGFycmF5LGlkKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYoYXJyYXlbaV0uZ2V0SWQoKSA9PT0gaWQpIHJldHVybiBpO1xyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn07XHJcbmV4cG9ydHMuZ2V0SW5kZXhCeUlkID0gZ2V0SW5kZXhCeUlkO1xyXG5cclxuZXhwb3J0cy5hZGRPYmplY3RUb0FycmF5ID0gZnVuY3Rpb24oYXJyYXksb2JqLGV4cGVjdGVkVHlwZSkge1xyXG4gIGlmKGV4cGVjdGVkVHlwZSAhPT0gdW5kZWZpbmVkICYmIGV4cGVjdGVkVHlwZSAhPT0gbnVsbCkge1xyXG4gICAgaWYoZXhwZWN0ZWRUeXBlLmlzUHJvdG90eXBlT2Yob2JqKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHR5cGUgb2Ygb2JqZWN0IHBhc3NlZC4gRXhwZWN0ZWQgJ1xyXG4gICAgICArZXhwZWN0ZWRUeXBlLmNvbnN0cnVjdG9yLm5hbWUrJyBvYmplY3QuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmKGluZGV4T2ZPYmplY3QoYXJyYXksb2JqKSA9PT0gLTEpIHtcclxuICAgIGFycmF5LnB1c2gob2JqKTtcclxuICB9XHJcbiAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuLypleHBvcnRzLnJlbW92ZU9iamVjdEJ5SWQgPSBmdW5jdGlvbihhcnJheSxpZCkge1xyXG4gIGxldCBpbmRleCA9IGdldEluZGV4QnlJZChhcnJheSxpZCk7XHJcbiAgaWYoaW5kZXggIT09IC0xKSB7XHJcbiAgICBsZXQgc3BsaWNlZCA9IGFycmF5LnNwbGljZShpbmRleCwxKTtcclxuICAgIGlmKHNwbGljZWQuZGlzcG9zZSkgc3BsaWNlZC5kaXNwb3NlKCk7XHJcbiAgfVxyXG4gIHJldHVybiBhcnJheTtcclxufSovXHJcblxyXG5leHBvcnRzLnJlbW92ZU9iamVjdEZyb21BcnJheSA9IGZ1bmN0aW9uKGFycmF5LG9iaikge1xyXG4gIGxldCBpbmRleCA9IGluZGV4T2ZPYmplY3QoYXJyYXksb2JqKTtcclxuICBpZihpbmRleCAhPT0gLTEpIHtcclxuICAgIGxldCBzcGxpY2VkID0gYXJyYXkuc3BsaWNlKGluZGV4LDEpO1xyXG4gICAgaWYoc3BsaWNlZC5kaXNwb3NlKSBzcGxpY2VkLmRpc3Bvc2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IEJhc2VOb2RlIGZyb20gJy4uL2NvcmUvQmFzZU5vZGUnO1xyXG5pbXBvcnQgUHJvcCAgIGZyb20gJy4uL2NvcmUvUHJvcCc7XHJcblxyXG5sZXQgQW5zd2VyTm9kZSA9IChmdW5jdGlvbigpIHtcclxuICAvL1dlYWsgbWFwcyBhcmUgbmV3IGZlYXR1cmUgdG8gSmF2YVNjcmlwdC4gV2UgY2FuIHN0b3JlIHByaXZhdGVcclxuICAvL29iamVjdCBwcm9wZXJ0aWVzIGluIGtleS92YWx1ZSBwYWlycyB1c2luZyBvdXIgaW5zdGFuY2UgYXMgdGhlIGtleSxcclxuICAvL2FuZCBvdXIgY2xhc3MgY2FuIGNhcHR1cmUgdGhvc2Uga2V5L3ZhbHVlIG1hcHMgaW4gYSBjbG9zdXJlLlxyXG4gIGxldCBfdGV4dCA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4gIHJldHVybiBjbGFzcyBBbnN3ZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSxycGdzKSB7XHJcbiAgICAgIHN1cGVyKGRhdGEscnBncyk7XHJcbiAgICAgIF90ZXh0LnNldCh0aGlzLGRhdGEudGV4dCA/IGRhdGEudGV4dCA6ICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhKCkge1xyXG4gICAgICBsZXQgZGF0YSA9IHN1cGVyLmdldERhdGEoKTtcclxuICAgICAgZGF0YS50ZXh0ID0gdGhpcy5nZXRUZXh0KCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFRleHQodmFsdWUpIHtcclxuICAgICAgX3RleHQuc2V0KHRoaXMsdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHQoKSB7XHJcbiAgICAgIHJldHVybiBfdGV4dC5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGFsaygpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0Fuc3dlck5vZGU6OmdldFRhbGsnLHRoaXMuZ2V0V2lyZXMoUHJvcC5HT1RPKSk7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFdpcmVzKFByb3AuR09UTylbMF07XHJcbiAgICB9XHJcblxyXG4gICAgY2FuU2V0V2lyZVR5cGUodHlwZSkge1xyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIFByb3AuVklTSUJJTElUWTpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVzKFByb3AuVklTSUJJTElUWSkubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIGNhc2UgUHJvcC5BQ1RJVklUWTpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVzKFByb3AuQUNUSVZJVFkpLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICBjYXNlIFByb3AuR09UTzpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVzKFByb3AuR09UTykubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIF90ZXh0LmRlbGV0ZSh0aGlzKTtcclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG59KSgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFuc3dlck5vZGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgQ29tcG91bmROb2RlIGZyb20gJy4uL2NvcmUvQ29tcG91bmROb2RlJztcclxuaW1wb3J0IFByb3AgICAgIGZyb20gJy4uL2NvcmUvUHJvcCc7XHJcbmltcG9ydCBVdGlscyAgICAgICAgZnJvbSAnLi4vY29yZS9VdGlscyc7XHJcblxyXG5cclxuY29uc3QgS0VZX1RBTEtTID0gJ3RhbGtzJztcclxuXHJcbmxldCBEaWFsb2dOb2RlID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBfc3RhcnQgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICByZXR1cm4gY2xhc3MgRGlhbG9nTm9kZSBleHRlbmRzIENvbXBvdW5kTm9kZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGF0YSxycGdzKSB7XHJcbiAgICAgIHN1cGVyKGRhdGEscnBncyk7XHJcbiAgICAgIF9zdGFydC5zZXQodGhpcyxkYXRhLnN0YXJ0VGFsayA/IGRhdGEuc3RhcnRUYWxrIDogJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGEoKSB7XHJcbiAgICAgIGxldCBkYXRhID0gc3VwZXIuZ2V0RGF0YSgpO1xyXG4gICAgICBkYXRhLnN0YXJ0VGFsayA9IHRoaXMuZ2V0U3RhcnRUYWxrKCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbkFkZENoaWxkKHR5cGUpIHtcclxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdUYWxrTm9kZSc7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U3RhcnRUYWxrKHRhbGtJZCkge1xyXG4gICAgICBfc3RhcnQuc2V0KHRoaXMsdGFsa0lkKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdGFydFRhbGsoKSB7XHJcbiAgICAgIHJldHVybiBfc3RhcnQuZ2V0KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhblNldFdpcmVUeXBlKHR5cGUpIHtcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBQcm9wLlZJU0lCSUxJVFk6XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRXaXJlcyhQcm9wLlZJU0lCSUxJVFkpLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICBjYXNlIFByb3AuQUNUSVZJVFk6XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRXaXJlcyhQcm9wLkFDVElWSVRZKS5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgX3N0YXJ0LmRlbGV0ZSh0aGlzKTtcclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pKCk7XHJcbm1vZHVsZS5leHBvcnRzID0gRGlhbG9nTm9kZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgRGlhbG9nV2Fsa2VyID0gKGZ1bmN0aW9uKCl7XHJcbiAgbGV0IF9jdXJyVGFsayA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgbGV0IF9ycGdzID0gbmV3IFdlYWtNYXAoKTtcclxuICBsZXQgX2RpYWxvZyA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4gIHJldHVybiBjbGFzcyBEaWFsb2dXYWxrZXIge1xyXG4gICAgY29uc3RydWN0b3IocnBncykge1xyXG4gICAgICBfcnBncy5zZXQodGhpcyxycGdzKTtcclxuICAgICAgX2RpYWxvZy5zZXQodGhpcyxudWxsKTtcclxuICAgICAgX2N1cnJUYWxrLnNldCh0aGlzLG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICBsZXQgZGlhbG9nID0gX2RpYWxvZy5nZXQodGhpcyk7XHJcbiAgICAgIGlmKGRpYWxvZyAhPT0gbnVsbCl7XHJcbiAgICAgICAgdGhpcy5zZXRUYWxrKGRpYWxvZy5nZXRTdGFydFRhbGsoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZmluZE5vZGUobm9kZUlkKSB7XHJcbiAgICAgIHJldHVybiBfcnBncy5nZXQodGhpcykuZmluZE5vZGUobm9kZUlkKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXREaWFsb2coZGlhbG9nSWQpIHtcclxuICAgICAgbGV0IGRpYWxvZyA9IHRoaXMuX2ZpbmROb2RlKGRpYWxvZ0lkKTtcclxuICAgICAgaWYoZGlhbG9nID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWFsb2dOb2RlIHdpdGggdGhlIGlkIFwiJHtkaWFsb2dJZH1cIiBkb2VzIG5vdCBleGlzdHMuYCk7XHJcbiAgICAgIH1cclxuICAgICAgX2RpYWxvZy5zZXQodGhpcyxkaWFsb2cpO1xyXG4gICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGFsayh0YWxrSWQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ3NldFRhbGsnLHRhbGtJZCk7XHJcbiAgICAgIGxldCB0YWxrID0gdGhpcy5fZmluZE5vZGUodGFsa0lkKTtcclxuICAgICAgaWYodGFsayA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFsa05vZGUgd2l0aCB0aGUgaWQgXCIke3RhbGtJZH1cIiBkb2VzIG5vdCBleGlzdHMuYCk7XHJcbiAgICAgIH1cclxuICAgICAgX2N1cnJUYWxrLnNldCh0aGlzLHRhbGspO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENvbnZlcnNhdGlvbigpIHtcclxuICAgICAgbGV0IGNvbnZlcnNhdGlvbiA9IHt9O1xyXG4gICAgICBjb252ZXJzYXRpb24udGV4dCA9IF9jdXJyVGFsay5nZXQodGhpcykuZ2V0VGV4dCgpO1xyXG4gICAgICBsZXQgY2hpbGRyZW4gPSBfY3VyclRhbGsuZ2V0KHRoaXMpLmdldENoaWxkcmVuKCk7XHJcbiAgICAgIGNvbnZlcnNhdGlvbi5vcHRpb25zID0gY2hpbGRyZW4ubWFwKChhbnN3ZXJJZCkgPT4ge1xyXG4gICAgICAgIGxldCBhbnN3ZXIgPSB0aGlzLl9maW5kTm9kZShhbnN3ZXJJZCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlkOmFuc3dlci5nZXRJZCgpLFxyXG4gICAgICAgICAgdGV4dDphbnN3ZXIuZ2V0VGV4dCgpLFxyXG4gICAgICAgICAgaXNBY3RpdmU6YW5zd2VyLmlzQWN0aXZlKCksXHJcbiAgICAgICAgICBpc1Zpc2libGU6YW5zd2VyLmlzVmlzaWJsZSgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RPcHRpb24oaWQpIHtcclxuICAgICAgbGV0IGNoaWxkcmVuID0gX2N1cnJUYWxrLmdldCh0aGlzKS5nZXRDaGlsZHJlbigpO1xyXG4gICAgICBsZXQgYW5zd2VySWQgPSBjaGlsZHJlbi5maWx0ZXIoKGN1cnJJZCxpbmRleCxhcnJheSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBjdXJySWQgPT09IGlkO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYoYW5zd2VySWRbMF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxldCBhbnN3ZXJOb2RlID0gdGhpcy5fZmluZE5vZGUoYW5zd2VySWRbMF0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdzZWxlY3RPcHRpb246OmFuc3dlck5vZGUnLGFuc3dlck5vZGUsYW5zd2VyTm9kZS5nZXRJZCgpKTtcclxuICAgICAgICBpZihhbnN3ZXJOb2RlICE9PSBudWxsKSB0aGlzLnNldFRhbGsoYW5zd2VyTm9kZS5nZXRUYWxrKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59KSgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IERpYWxvZ1dhbGtlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCBVdGlscyAgICAgIGZyb20gJy4uL2NvcmUvVXRpbHMnO1xyXG5pbXBvcnQgQ29tcG91bmROb2RlIGZyb20gJy4uL2NvcmUvQ29tcG91bmROb2RlJztcclxuaW1wb3J0IFByb3AgICBmcm9tICcuLi9jb3JlL1Byb3AnO1xyXG5cclxubGV0IFRhbGtOb2RlID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICBsZXQgX3RleHQgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICByZXR1cm4gY2xhc3MgVGFsa05vZGUgZXh0ZW5kcyBDb21wb3VuZE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSxycGdzKSB7XHJcbiAgICAgIHN1cGVyKGRhdGEscnBncyk7XHJcbiAgICAgIF90ZXh0LnNldCh0aGlzLGRhdGEudGV4dCA/IGRhdGEudGV4dCA6ICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhKCkge1xyXG4gICAgICBsZXQgZGF0YSA9IHN1cGVyLmdldERhdGEoKTtcclxuICAgICAgZGF0YS50ZXh0ID0gdGhpcy5nZXRUZXh0KCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFRleHQodmFsdWUpIHtcclxuICAgICAgX3RleHQuc2V0KHRoaXMsdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHQoKSB7XHJcbiAgICAgIHJldHVybiBfdGV4dC5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FuQWRkQ2hpbGQodHlwZSkge1xyXG4gICAgICByZXR1cm4gdHlwZSA9PT0gJ0Fuc3dlck5vZGUnO1xyXG4gICAgfVxyXG5cclxuICAgIGNhblNldFdpcmVUeXBlKHR5cGUpIHtcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBQcm9wLkdPVE86XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICBfdGV4dC5kZWxldGUodGhpcyk7XHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFRhbGtOb2RlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCBCYXNlTm9kZSAgIGZyb20gJy4uL2NvcmUvQmFzZU5vZGUnO1xyXG5pbXBvcnQgUHJvcCAgIGZyb20gJy4uL2NvcmUvUHJvcCc7XHJcbmltcG9ydCBjb21waWxlciAgIGZyb20gJ0ByaXNpbmdzdGFjay9ueC1jb21waWxlJztcclxuXHJcbmxldCBTY3JpcHROb2RlID0gKGZ1bmN0aW9uKCl7XHJcbiAgbGV0IF9sYWJlbCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgbGV0IF9zY3JpcHQgPSBuZXcgV2Vha01hcCgpO1xyXG4gIGxldCBfY29tcGlsZWQgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICByZXR1cm4gY2xhc3MgU2NyaXB0Tm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEscnBncykge1xyXG4gICAgICBzdXBlcihkYXRhLHJwZ3MpO1xyXG4gICAgICBfbGFiZWwuc2V0KHRoaXMsZGF0YS5sYWJlbCA/IGRhdGEubGFiZWwgOiAnJyk7XHJcbiAgICAgIF9zY3JpcHQuc2V0KHRoaXMsZGF0YS5zY3JpcHQgPyBkYXRhLnNjcmlwdCA6IGByZXR1cm4gdHJ1ZTtgKTtcclxuICAgICAgY29tcGlsZXIuZXhwb3NlKCdjb25zb2xlJyk7XHJcbiAgICAgIF9jb21waWxlZC5zZXQodGhpcyxjb21waWxlci5jb21waWxlQ29kZShfc2NyaXB0LmdldCh0aGlzKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldExhYmVsKHRleHQpIHtcclxuICAgICAgX2xhYmVsLnNldCh0aGlzLHRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldExhYmVsKCkge1xyXG4gICAgICByZXR1cm4gX2xhYmVsLmdldCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTY3JpcHQoc2NyaXB0KSB7XHJcbiAgICAgIF9zY3JpcHQuc2V0KHRoaXMsc2NyaXB0KTtcclxuICAgICAgX2NvbXBpbGVkLnNldCh0aGlzLGNvbXBpbGVyLmNvbXBpbGVDb2RlKF9zY3JpcHQuZ2V0KHRoaXMpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2NyaXB0KCkge1xyXG4gICAgICByZXR1cm4gX3NjcmlwdC5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZXhlY3V0ZSgpIHtcclxuICAgICAgcmV0dXJuIF9jb21waWxlZC5nZXQodGhpcykoe3JwZ3M6dGhpcy5nZXRSUEdTKCl9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhKCkge1xyXG4gICAgICBsZXQgZGF0YSA9IHN1cGVyLmdldERhdGEoKTtcclxuICAgICAgZGF0YS5sYWJlbCA9IHRoaXMuZ2V0TGFiZWwoKTtcclxuICAgICAgZGF0YS5zY3JpcHQgPSB0aGlzLmdldFNjcmlwdCgpO1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRXaXJlKHR5cGUsbGlua0lkKSB7fVxyXG4gICAgZ2V0V2lyZXModHlwZSkge31cclxuICAgIHJlbW92ZVdpcmUodHlwZSxsaW5rSWQpIHt9XHJcblxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgX2xhYmVsLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgX3NjcmlwdC5kZWxldGUodGhpcyk7XHJcbiAgICAgIF9jb21waWxlZC5kZWxldGUodGhpcyk7XHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxufSkoKTtcclxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHROb2RlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IENvbXBvdW5kTm9kZSBmcm9tICcuLi9jb3JlL0NvbXBvdW5kTm9kZSc7XHJcbmltcG9ydCBRdWVzdFN0YXR1cyAgZnJvbSAnLi9RdWVzdFN0YXR1cyc7XHJcblxyXG5jb25zdCBLRVlfVEFTS1MgPSAndGFza3MnXHJcblxyXG5sZXQgUXVlc3ROb2RlID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBfdGl0bGUgPSBuZXcgV2Vha01hcCgpO1xyXG4gIGxldCBfZGVzY3JpcHRpb24gPSBuZXcgV2Vha01hcCgpO1xyXG4gIGxldCBfc3RhdHVzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbiAgcmV0dXJuIGNsYXNzIFF1ZXN0Tm9kZSBleHRlbmRzIENvbXBvdW5kTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLHJwZ3MpIHtcclxuICAgICAgc3VwZXIoZGF0YSxycGdzKTtcclxuICAgICAgX3RpdGxlLnNldCh0aGlzLGRhdGEudGl0bGUgPyBkYXRhLnRpdGxlIDogJycpO1xyXG4gICAgICBfZGVzY3JpcHRpb24uc2V0KHRoaXMsZGF0YS5kZXNjcmlwdGlvbiA/IGRhdGEuZGVzY3JpcHRpb24gOiAnJyk7XHJcbiAgICAgIF9zdGF0dXMuc2V0KHRoaXMsZGF0YS5zdGF0dXMgPyBkYXRhLnN0YXR1cyA6IFF1ZXN0U3RhdHVzLklOQ09NUExFVEUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGEoKSB7XHJcbiAgICAgIGxldCBkYXRhID0gc3VwZXIuZ2V0RGF0YSgpO1xyXG4gICAgICBkYXRhLnRpdGxlID0gdGhpcy5nZXRUaXRsZSgpO1xyXG4gICAgICBkYXRhLmRlc2NyaXB0aW9uID0gdGhpcy5nZXREZXNjcmlwdGlvbigpO1xyXG4gICAgICBkYXRhLnN0YXR1cyA9IHRoaXMuZ2V0U3RhdHVzKCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbkFkZENoaWxkKHR5cGUpIHtcclxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdUYXNrTm9kZSc7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGl0bGUodmFsdWUpIHtcclxuICAgICAgX3RpdGxlLnNldCh0aGlzLHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUaXRsZSgpIHtcclxuICAgICAgcmV0dXJuIF90aXRsZS5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGVzY3JpcHRpb24odmFsdWUpIHtcclxuICAgICAgX2Rlc2NyaXB0aW9uLnNldCh0aGlzLHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREZXNjcmlwdGlvbigpIHtcclxuICAgICAgcmV0dXJuIF9kZXNjcmlwdGlvbi5nZXQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U3RhdHVzKHZhbHVlKSB7XHJcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICBjYXNlIFF1ZXN0U3RhdHVzLkNPTVBMRVRFRDpcclxuICAgICAgICBjYXNlIFF1ZXN0U3RhdHVzLkZBSUxFRDpcclxuICAgICAgICAgIF9zdGF0dXMuc2V0KHRoaXMsdmFsdWUpO1xyXG4gICAgICAgIGNhc2UgUXVlc3RTdGF0dXMuSU5DT01QTEVURTpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgX3N0YXR1cy5zZXQodGhpcyxRdWVzdFN0YXR1cy5JTkNPTVBMRVRFKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN0YXR1cygpIHtcclxuICAgICAgcmV0dXJuIF9zdGF0dXMuZ2V0KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIF90aXRsZS5kZWxldGUodGhpcyk7XHJcbiAgICAgIF9kZXNjcmlwdGlvbi5kZWxldGUodGhpcyk7XHJcbiAgICAgIF9zdGF0dXMuZGVsZXRlKHRoaXMpO1xyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcbm1vZHVsZS5leHBvcnRzID0gUXVlc3ROb2RlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuY29uc3QgSU5DT01QTEVURSA9ICdxdWVzdEluY29tcGxldGUnO1xyXG5jb25zdCBDT01QTEVURUQgPSAncXVlc3RDb21wbGV0ZWQnO1xyXG5jb25zdCBGQUlMRUQgPSAncXVlc3RGYWlsZWQnO1xyXG5cclxuZXhwb3J0cy5JTkNPTVBMRVRFID0gSU5DT01QTEVURTtcclxuZXhwb3J0cy5DT01QTEVURUQgPSBDT01QTEVURUQ7XHJcbmV4cG9ydHMuRkFJTEVEID0gRkFJTEVEO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IEJhc2VOb2RlIGZyb20gJy4uL2NvcmUvQmFzZU5vZGUnO1xyXG5cclxubGV0IFRhc2tOb2RlID0gKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIGNsYXNzIFRhc2tOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgICBzdXBlcihkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvL3RvIGRvXHJcbiAgfTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGFza05vZGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgQmFzZU5vZGUgZnJvbSAnLi4vY29yZS9CYXNlTm9kZSc7XHJcbmltcG9ydCBWYXJpYWJsZVR5cGUgZnJvbSAnLi9WYXJpYWJsZVR5cGUnO1xyXG5cclxubGV0IFZhcmlhYmxlTm9kZSA9IChmdW5jdGlvbigpe1xyXG4gIGxldCBfdmFsdWUgPSBuZXcgV2Vha01hcCgpO1xyXG4gIGxldCBfdHlwZSA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4gIGZ1bmN0aW9uIF9wYXJzZUJvb2xlYW4odmFsKSB7XHJcbiAgICBsZXQgaXNCb29sID0gdHlwZW9mIHZhbCA9PT0gVmFyaWFibGVUeXBlLkJPT0xFQU47XHJcbiAgICBpZihpc0Jvb2wpIHtcclxuICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaChTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpLnRyaW0oKSl7XHJcbiAgICAgICAgY2FzZSBcInRydWVcIjogY2FzZSBcInllc1wiOiBjYXNlIFwiMVwiOiByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjYXNlIFwiZmFsc2VcIjogY2FzZSBcIm5vXCI6IGNhc2UgXCIwXCI6IGNhc2UgbnVsbDogcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBCb29sZWFuKHZhbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9wYXJzZVN0cmluZyh2YWwpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBWYXJpYWJsZVR5cGUuU1RSSU5HID8gdmFsIDogU3RyaW5nKHZhbCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfcGFyc2VOdW1iZXIodmFsKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gVmFyaWFibGVUeXBlLk5VTUJFUiA/IHZhbCA6IHBhcnNlRmxvYXQodmFsKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9wYXJzZVZhbHVlKHZhbCx0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSBWYXJpYWJsZVR5cGUuQk9PTEVBTjpcclxuICAgICAgICByZXR1cm4gX3BhcnNlQm9vbGVhbih2YWwpO1xyXG4gICAgICBjYXNlIFZhcmlhYmxlVHlwZS5OVU1CRVI6XHJcbiAgICAgICAgcmV0dXJuIF9wYXJzZU51bWJlcih2YWwpO1xyXG4gICAgICBjYXNlIFZhcmlhYmxlVHlwZS5TVFJJTkc6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIF9wYXJzZVN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNsYXNzIFZhcmlhYmxlTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEscnBncykge1xyXG4gICAgICBzdXBlcihkYXRhLHJwZ3MpO1xyXG4gICAgICBfdHlwZS5zZXQodGhpcywgZGF0YS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpID8gZGF0YS50eXBlIDogVmFyaWFibGVUeXBlLlNUUklORyk7XHJcbiAgICAgIF92YWx1ZS5zZXQodGhpcywgZGF0YS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSA/IF9wYXJzZVZhbHVlKGRhdGEudmFsdWUsX3R5cGUuZ2V0KHRoaXMpKSA6ICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhKCkge1xyXG4gICAgICBsZXQgZGF0YSA9IHN1cGVyLmdldERhdGEoKTtcclxuICAgICAgZGF0YS50eXBlID0gdGhpcy5nZXRUeXBlKCk7XHJcbiAgICAgIGRhdGEudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFZhbHVlKHZhbCkge1xyXG4gICAgICBfdmFsdWUuc2V0KHRoaXMsX3BhcnNlVmFsdWUodmFsLF90eXBlLmdldCh0aGlzKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICByZXR1cm4gX3ZhbHVlLmdldCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gX3R5cGUuZ2V0KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhblNldFdpcmVUeXBlKHR5cGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIF92YWx1ZS5kZWxldGUodGhpcyk7XHJcbiAgICAgIF90eXBlLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZhcmlhYmxlTm9kZTtcclxuIiwiY29uc3QgQk9PTEVBTiA9ICdib29sZWFuJztcclxuY29uc3QgU1RSSU5HID0gJ3N0cmluZyc7XHJcbmNvbnN0IE5VTUJFUiA9ICdudW1iZXInO1xyXG5cclxuZXhwb3J0cy5CT09MRUFOID0gQk9PTEVBTjtcclxuZXhwb3J0cy5TVFJJTkcgPSBTVFJJTkc7XHJcbmV4cG9ydHMuTlVNQkVSID0gTlVNQkVSO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IGRhdGEgZnJvbSAnLi4vZGF0YS9kYXRhLmpzb24nO1xyXG5pbXBvcnQgUlBHU3lzdGVtIGZyb20gJy4vcnBncy9SUEdTeXN0ZW0nO1xyXG5pbXBvcnQgRGlhbG9nV2Fsa2VyIGZyb20gJy4vcnBncy9kaWFsb2dzL0RpYWxvZ1dhbGtlcic7XHJcblxyXG4oZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG4gICQoZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IHJwZ3MxID0gbmV3IFJQR1N5c3RlbSgpO1xyXG4gICAgcnBnczFcclxuICAgIC5hZGRBY3RvcignYWN0MScse25hbWU6J0FkYW0nfSkuc2V0V2lyZSgnZGlhbG9nJywnZGxnMScpXHJcbiAgICAuYWRkQ29uZGl0aW9uKCdjb25kMScse3NjcmlwdDpgcmV0dXJuIHJwZ3MuZ2V0VmFyKCdiMScpO2B9KVxyXG4gICAgLmFkZERpYWxvZygnZGxnMScse3N0YXJ0VGFsazondGxrMCd9KVxyXG4gICAgICAuYWRkVGFsaygndGxrMCcse3RleHQ6J1RoaXMgaXMgdGFsayAwLid9KVxyXG4gICAgICAgIC5hZGRBbnN3ZXIoJ3RsazBhbnMxJyx7dGV4dDonQW5zd2VyMSd9KS5zZXRXaXJlKCd2aXNpYmlsaXR5JywnY29uZDEnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRXaXJlKCdnb3RvJywndGxrMScpXHJcbiAgICAgICAgLmFkZEFuc3dlcigndGxrMGFuczInLHt0ZXh0OidBbnN3ZXIyJ30pLnNldFdpcmUoJ2dvdG8nLCd0bGsyJylcclxuICAgICAgICAuYWRkQW5zd2VyKCd0bGswYW5zMycse3RleHQ6J0Fuc3dlcjMnfSkuc2V0V2lyZSgnZ290bycsJ3RsazMnKVxyXG5cclxuICAgICAgLmFkZFRhbGsoJ3RsazEnLHt0ZXh0OidUaGlzIGlzIHRhbGsgMS4nfSlcclxuICAgICAgICAuYWRkQW5zd2VyKCd0bGsxYW5zMScse3RleHQ6J0Fuc3dlcjEnfSlcclxuXHJcbiAgICAgIC5hZGRUYWxrKCd0bGsyJyx7dGV4dDonVGhpcyBpcyB0YWxrIDIuJ30pXHJcbiAgICAgICAgLmFkZEFuc3dlcigndGxrMmFuczEnLHt0ZXh0OidBbnN3ZXIxJ30pXHJcblxyXG4gICAgICAuYWRkVGFsaygndGxrMycse3RleHQ6J1RoaXMgaXMgdGFsayAzLid9KVxyXG4gICAgICAgIC5hZGRBbnN3ZXIoJ3RsazNhbnMxJyx7dGV4dDonQW5zd2VyMSd9KVxyXG4gICAgLmFkZFZhcmlhYmxlKCdiMScse3R5cGU6J2Jvb2xlYW4nLHZhbHVlOmZhbHNlfSlcclxuICAgIC5hZGRWYXJpYWJsZSgnczEnLHt0eXBlOidzdHJpbmcnLHZhbHVlOidUaGlzIGlzIG1lc3NhZ2UgZnJvbSBjb21waWxlZCBjb2RlISd9KVxyXG4gICAgLmFkZFZhcmlhYmxlKCduMScse3R5cGU6J251bWJlcicsdmFsdWU6NTZ9KVxyXG4gICAgbGV0IGNvbmQgPSBycGdzMS5nZXRDb25kaXRpb24oJ2NvbmQxJyk7XHJcbiAgICBjb25zb2xlLmxvZyhjb25kLmV4ZWN1dGUoKSk7XHJcbiAgICBsZXQgYjEgPSBycGdzMS5nZXRWYXJpYWJsZSgnYjEnKTtcclxuICAgIGxldCBzMSA9IHJwZ3MxLmdldFZhcmlhYmxlKCdzMScpO1xyXG4gICAgbGV0IG4xID0gcnBnczEuZ2V0VmFyaWFibGUoJ24xJyk7XHJcblxyXG4gICAgbGV0IHJwZ3MxU2VyaWFsaXplZCA9IHJwZ3MxLnNlcmlhbGl6ZURhdGEoKTtcclxuICAgIGNvbnNvbGUubG9nKFwicnBnczFcIixycGdzMVNlcmlhbGl6ZWQpO1xyXG5cclxuICAgIGxldCBycGdzMiA9IG5ldyBSUEdTeXN0ZW0oSlNPTi5wYXJzZShycGdzMVNlcmlhbGl6ZWQpKTtcclxuXHJcbiAgICBsZXQgcnBnczJTZXJpYWxpemVkID0gcnBnczIuc2VyaWFsaXplRGF0YSgpO1xyXG4gICAgY29uc29sZS5sb2coXCJycGdzMlwiLHJwZ3MyU2VyaWFsaXplZCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJkYXRhIGNyZWF0ZWQgaXMgZXF1YWwgdG8gZGF0YSBwYXJzZWQ6XCIscnBnczFTZXJpYWxpemVkID09PSBycGdzMlNlcmlhbGl6ZWQpO1xyXG5cclxuICAgIGxldCB3YWxrZXIgPSBuZXcgRGlhbG9nV2Fsa2VyKHJwZ3MyKTtcclxuICAgIHdhbGtlci5zZXREaWFsb2coJ2RsZzEnKTtcclxuICAgIGNvbnNvbGUubG9nKCdjb252ZXJzYXRpb24xOicsd2Fsa2VyLmdldENvbnZlcnNhdGlvbigpKTtcclxuICAgIHdhbGtlci5zZWxlY3RPcHRpb24oJ3RsazBhbnMxJyk7XHJcbiAgICBjb25zb2xlLmxvZygnY29udmVyc2F0aW9uMjonLHdhbGtlci5nZXRDb252ZXJzYXRpb24oKSk7XHJcbiAgfSk7XHJcblxyXG59KShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xyXG4iXX0=
